(function () {
	var isOutdated = function () {
		return !~window.navigator.userAgent.indexOf('Nintendo') &&
		       typeof MutationObserver === 'undefined';
	};

	var scripts = document.getElementsByTagName('script');
	var src = scripts[scripts.length - 1].src;

	/**
	 * Sets a cookie on the document.
	 * @param {string} name - Name of the cookie.
	 * @param {string} value - Value of the cookie.
	 * @param {Date} expires - Date object representing when the cookie should expire.
	 */
	var setCookie = function (name, value, expires) {
		document.cookie = name + '=' + value + (expires ? '; expires=' + expires.toUTCString() : '');
	};

	/**
	 * Gets the value of a cookie from the document.
	 * @return {string} Value of cookie.
	 */
	var getCookie = function (name) {
		var match = document.cookie.match(new RegExp(name + '=([^;]+);?'));
		return match && match[1];
	};

	var onDOMContentLoaded = function() {
		var elem = document.createElement('div');
		elem.innerHTML = '<div id="nclood-outdated" lang="en"><div class="outdated-message"><span class="wario-waluigi-ball"></span><span class="uh-oh"><h1>Uh-oh</h1><p>You\'re using an <b>older version</b> of a browser that doesn\'t play well with our site. Power up your experience by <b>upgrading</b> to the latest version of these supported browsers:</p><div class="browser-downloads"><a href="https://www.google.com/chrome/browser/desktop/" target="_blank">Google Chrome</a><span class="browser-separator">|</span><a href="http://windows.microsoft.com/en-us/internet-explorer/download-ie" target="_blank">Internet Explorer</a><span class="browser-separator">|</span><a href="https://www.mozilla.org/en-US/firefox/new/" target="_blank">Mozilla Firefox</a><span class="browser-separator">|</span><a href="https://support.apple.com/en-us/HT204416" target="_blank">Safari</a></div><a id="outdated-continue" href="#">Continue to site</a></span></div><div class="outdated-overlay"></div></div>';
		var outdated = elem.firstChild;
		document.body.appendChild(outdated);
		var onContinue = function () {
			setCookie('outdated-warning', true, new Date(Date.now() + 1000 * 60 * 60 * 24 * 3));
			outdated.parentNode.removeChild(outdated);
		};
		if (window.addEventListener) {
			document.getElementById('outdated-continue').addEventListener('click', onContinue);
		} else if (window.attachEvent) {
			document.getElementById('outdated-continue').attachEvent('onclick', onContinue);
		}
	};

	// Check if they've been warned already
	if (getCookie('outdated-warning') === 'true') return;
	// If their browser is outdated, display the warning
	if (isOutdated()) {
		if (document.addEventListener) document.addEventListener("DOMContentLoaded", onDOMContentLoaded);
		else {
			document.onreadystatechange = function() {
				if (document.readyState == 'complete') onDOMContentLoaded();
			};
		}
	}

})();

/* Riot v2.3.18, @license MIT */

;(function(window, undefined) {
  'use strict';
var riot = { version: 'v2.3.18', settings: {} },
  // be aware, internal usage
  // ATTENTION: prefix the global dynamic variables with `__`

  // counter to give a unique id to all the Tag instances
  __uid = 0,
  // tags instances cache
  __virtualDom = [],
  // tags implementation cache
  __tagImpl = {},

  /**
   * Const
   */
  GLOBAL_MIXIN = '__global_mixin',

  // riot specific prefixes
  RIOT_PREFIX = 'riot-',
  RIOT_TAG = RIOT_PREFIX + 'tag',
  RIOT_TAG_IS = 'data-is',

  // for typeof == '' comparisons
  T_STRING = 'string',
  T_OBJECT = 'object',
  T_UNDEF  = 'undefined',
  T_FUNCTION = 'function',
  // special native tags that cannot be treated like the others
  SPECIAL_TAGS_REGEX = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,
  RESERVED_WORDS_BLACKLIST = ['_item', '_id', '_parent', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],

  // version# for IE 8-11, 0 for others
  IE_VERSION = (window && window.document || {}).documentMode | 0,

  // detect firefox to fix #1374
  FIREFOX = window && !!window.InstallTrigger
/* istanbul ignore next */
riot.observable = function(el) {

  /**
   * Extend the original object or create a new empty one
   * @type { Object }
   */

  el = el || {}

  /**
   * Private variables and methods
   */
  var callbacks = {},
    slice = Array.prototype.slice,
    onEachEvent = function(e, fn) { e.replace(/\S+/g, fn) }

  // extend the object adding the observable methods
  Object.defineProperties(el, {
    /**
     * Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.
     * @param  { String } events - events ids
     * @param  { Function } fn - callback function
     * @returns { Object } el
     */
    on: {
      value: function(events, fn) {
        if (typeof fn != 'function')  return el

        onEachEvent(events, function(name, pos) {
          (callbacks[name] = callbacks[name] || []).push(fn)
          fn.typed = pos > 0
        })

        return el
      },
      enumerable: false,
      writable: false,
      configurable: false
    },

    /**
     * Removes the given space separated list of `events` listeners
     * @param   { String } events - events ids
     * @param   { Function } fn - callback function
     * @returns { Object } el
     */
    off: {
      value: function(events, fn) {
        if (events == '*' && !fn) callbacks = {}
        else {
          onEachEvent(events, function(name) {
            if (fn) {
              var arr = callbacks[name]
              for (var i = 0, cb; cb = arr && arr[i]; ++i) {
                if (cb == fn) arr.splice(i--, 1)
              }
            } else delete callbacks[name]
          })
        }
        return el
      },
      enumerable: false,
      writable: false,
      configurable: false
    },

    /**
     * Listen to the given space separated list of `events` and execute the `callback` at most once
     * @param   { String } events - events ids
     * @param   { Function } fn - callback function
     * @returns { Object } el
     */
    one: {
      value: function(events, fn) {
        function on() {
          el.off(events, on)
          fn.apply(el, arguments)
        }
        return el.on(events, on)
      },
      enumerable: false,
      writable: false,
      configurable: false
    },

    /**
     * Execute all callback functions that listen to the given space separated list of `events`
     * @param   { String } events - events ids
     * @returns { Object } el
     */
    trigger: {
      value: function(events) {

        // getting the arguments
        var arglen = arguments.length - 1,
          args = new Array(arglen),
          fns

        for (var i = 0; i < arglen; i++) {
          args[i] = arguments[i + 1] // skip first argument
        }

        onEachEvent(events, function(name) {

          fns = slice.call(callbacks[name] || [], 0)

          for (var i = 0, fn; fn = fns[i]; ++i) {
            if (fn.busy) return
            fn.busy = 1
            fn.apply(el, fn.typed ? [name].concat(args) : args)
            if (fns[i] !== fn) { i-- }
            fn.busy = 0
          }

          if (callbacks['*'] && name != '*')
            el.trigger.apply(el, ['*', name].concat(args))

        })

        return el
      },
      enumerable: false,
      writable: false,
      configurable: false
    }
  })

  return el

}
/* istanbul ignore next */
;(function(riot) {

/**
 * Simple client-side router
 * @module riot-route
 */


var RE_ORIGIN = /^.+?\/\/+[^\/]+/,
  EVENT_LISTENER = 'EventListener',
  REMOVE_EVENT_LISTENER = 'remove' + EVENT_LISTENER,
  ADD_EVENT_LISTENER = 'add' + EVENT_LISTENER,
  HAS_ATTRIBUTE = 'hasAttribute',
  REPLACE = 'replace',
  POPSTATE = 'popstate',
  HASHCHANGE = 'hashchange',
  TRIGGER = 'trigger',
  MAX_EMIT_STACK_LEVEL = 3,
  win = typeof window != 'undefined' && window,
  doc = typeof document != 'undefined' && document,
  hist = win && history,
  loc = win && (hist.location || win.location), // see html5-history-api
  prot = Router.prototype, // to minify more
  clickEvent = doc && doc.ontouchstart ? 'touchstart' : 'click',
  started = false,
  central = riot.observable(),
  routeFound = false,
  debouncedEmit,
  base, current, parser, secondParser, emitStack = [], emitStackLevel = 0

/**
 * Default parser. You can replace it via router.parser method.
 * @param {string} path - current path (normalized)
 * @returns {array} array
 */
function DEFAULT_PARSER(path) {
  return path.split(/[/?#]/)
}

/**
 * Default parser (second). You can replace it via router.parser method.
 * @param {string} path - current path (normalized)
 * @param {string} filter - filter string (normalized)
 * @returns {array} array
 */
function DEFAULT_SECOND_PARSER(path, filter) {
  var re = new RegExp('^' + filter[REPLACE](/\*/g, '([^/?#]+?)')[REPLACE](/\.\./, '.*') + '$'),
    args = path.match(re)

  if (args) return args.slice(1)
}

/**
 * Simple/cheap debounce implementation
 * @param   {function} fn - callback
 * @param   {number} delay - delay in seconds
 * @returns {function} debounced function
 */
function debounce(fn, delay) {
  var t
  return function () {
    clearTimeout(t)
    t = setTimeout(fn, delay)
  }
}

/**
 * Set the window listeners to trigger the routes
 * @param {boolean} autoExec - see route.start
 */
function start(autoExec) {
  debouncedEmit = debounce(emit, 1)
  win[ADD_EVENT_LISTENER](POPSTATE, debouncedEmit)
  win[ADD_EVENT_LISTENER](HASHCHANGE, debouncedEmit)
  doc[ADD_EVENT_LISTENER](clickEvent, click)
  if (autoExec) emit(true)
}

/**
 * Router class
 */
function Router() {
  this.$ = []
  riot.observable(this) // make it observable
  central.on('stop', this.s.bind(this))
  central.on('emit', this.e.bind(this))
}

function normalize(path) {
  return path[REPLACE](/^\/|\/$/, '')
}

function isString(str) {
  return typeof str == 'string'
}

/**
 * Get the part after domain name
 * @param {string} href - fullpath
 * @returns {string} path from root
 */
function getPathFromRoot(href) {
  return (href || loc.href)[REPLACE](RE_ORIGIN, '')
}

/**
 * Get the part after base
 * @param {string} href - fullpath
 * @returns {string} path from base
 */
function getPathFromBase(href) {
  return base[0] == '#'
    ? (href || loc.href || '').split(base)[1] || ''
    : (loc ? getPathFromRoot(href) : href || '')[REPLACE](base, '')
}

function emit(force) {
  // the stack is needed for redirections
  var isRoot = emitStackLevel == 0
  if (MAX_EMIT_STACK_LEVEL <= emitStackLevel) return

  emitStackLevel++
  emitStack.push(function() {
    var path = getPathFromBase()
    if (force || path != current) {
      central[TRIGGER]('emit', path)
      current = path
    }
  })
  if (isRoot) {
    while (emitStack.length) {
      emitStack[0]()
      emitStack.shift()
    }
    emitStackLevel = 0
  }
}

function click(e) {
  if (
    e.which != 1 // not left click
    || e.metaKey || e.ctrlKey || e.shiftKey // or meta keys
    || e.defaultPrevented // or default prevented
  ) return

  var el = e.target
  while (el && el.nodeName != 'A') el = el.parentNode

  if (
    !el || el.nodeName != 'A' // not A tag
    || el[HAS_ATTRIBUTE]('download') // has download attr
    || !el[HAS_ATTRIBUTE]('href') // has no href attr
    || el.target && el.target != '_self' // another window or frame
    || el.href.indexOf(loc.href.match(RE_ORIGIN)[0]) == -1 // cross origin
  ) return

  if (el.href != loc.href) {
    if (
      el.href.split('#')[0] == loc.href.split('#')[0] // internal jump
      || base != '#' && getPathFromRoot(el.href).indexOf(base) !== 0 // outside of base
      || !go(getPathFromBase(el.href), el.title || doc.title) // route not found
    ) return
  }

  e.preventDefault()
}

/**
 * Go to the path
 * @param {string} path - destination path
 * @param {string} title - page title
 * @param {boolean} shouldReplace - use replaceState or pushState
 * @returns {boolean} - route not found flag
 */
function go(path, title, shouldReplace) {
  if (hist) { // if a browser
    path = base + normalize(path)
    title = title || doc.title
    // browsers ignores the second parameter `title`
    shouldReplace
      ? hist.replaceState(null, title, path)
      : hist.pushState(null, title, path)
    // so we need to set it manually
    doc.title = title
    routeFound = false
    emit()
    return routeFound
  }

  // Server-side usage: directly execute handlers for the path
  return central[TRIGGER]('emit', getPathFromBase(path))
}

/**
 * Go to path or set action
 * a single string:                go there
 * two strings:                    go there with setting a title
 * two strings and boolean:        replace history with setting a title
 * a single function:              set an action on the default route
 * a string/RegExp and a function: set an action on the route
 * @param {(string|function)} first - path / action / filter
 * @param {(string|RegExp|function)} second - title / action
 * @param {boolean} third - replace flag
 */
prot.m = function(first, second, third) {
  if (isString(first) && (!second || isString(second))) go(first, second, third || false)
  else if (second) this.r(first, second)
  else this.r('@', first)
}

/**
 * Stop routing
 */
prot.s = function() {
  this.off('*')
  this.$ = []
}

/**
 * Emit
 * @param {string} path - path
 */
prot.e = function(path) {
  this.$.concat('@').some(function(filter) {
    var args = (filter == '@' ? parser : secondParser)(normalize(path), normalize(filter))
    if (typeof args != 'undefined') {
      this[TRIGGER].apply(null, [filter].concat(args))
      return routeFound = true // exit from loop
    }
  }, this)
}

/**
 * Register route
 * @param {string} filter - filter for matching to url
 * @param {function} action - action to register
 */
prot.r = function(filter, action) {
  if (filter != '@') {
    filter = '/' + normalize(filter)
    this.$.push(filter)
  }
  this.on(filter, action)
}

var mainRouter = new Router()
var route = mainRouter.m.bind(mainRouter)

/**
 * Create a sub router
 * @returns {function} the method of a new Router object
 */
route.create = function() {
  var newSubRouter = new Router()
  // assign sub-router's main method
  var router = newSubRouter.m.bind(newSubRouter)
  // stop only this sub-router
  router.stop = newSubRouter.s.bind(newSubRouter)
  return router
}

/**
 * Set the base of url
 * @param {(str|RegExp)} arg - a new base or '#' or '#!'
 */
route.base = function(arg) {
  base = arg || '#'
  current = getPathFromBase() // recalculate current path
}

/** Exec routing right now **/
route.exec = function() {
  emit(true)
}

/**
 * Replace the default router to yours
 * @param {function} fn - your parser function
 * @param {function} fn2 - your secondParser function
 */
route.parser = function(fn, fn2) {
  if (!fn && !fn2) {
    // reset parser for testing...
    parser = DEFAULT_PARSER
    secondParser = DEFAULT_SECOND_PARSER
  }
  if (fn) parser = fn
  if (fn2) secondParser = fn2
}

/**
 * Helper function to get url query as an object
 * @returns {object} parsed query
 */
route.query = function() {
  var q = {}
  var href = loc.href || current
  href[REPLACE](/[?&](.+?)=([^&]*)/g, function(_, k, v) { q[k] = v })
  return q
}

/** Stop routing **/
route.stop = function () {
  if (started) {
    if (win) {
      win[REMOVE_EVENT_LISTENER](POPSTATE, debouncedEmit)
      win[REMOVE_EVENT_LISTENER](HASHCHANGE, debouncedEmit)
      doc[REMOVE_EVENT_LISTENER](clickEvent, click)
    }
    central[TRIGGER]('stop')
    started = false
  }
}

/**
 * Start routing
 * @param {boolean} autoExec - automatically exec after starting if true
 */
route.start = function (autoExec) {
  if (!started) {
    if (win) {
      if (document.readyState == 'complete') start(autoExec)
      // the timeout is needed to solve
      // a weird safari bug https://github.com/riot/route/issues/33
      else win[ADD_EVENT_LISTENER]('load', function() {
        setTimeout(function() { start(autoExec) }, 1)
      })
    }
    started = true
  }
}

/** Prepare the router **/
route.base()
route.parser()

riot.route = route
})(riot)
/* istanbul ignore next */

/**
 * The riot template engine
 * @version v2.3.22
 */

/**
 * riot.util.brackets
 *
 * - `brackets    ` - Returns a string or regex based on its parameter
 * - `brackets.set` - Change the current riot brackets
 *
 * @module
 */

var brackets = (function (UNDEF) {

  var
    REGLOB = 'g',

    R_MLCOMMS = /\/\*[^*]*\*+(?:[^*\/][^*]*\*+)*\//g,

    R_STRINGS = /"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'/g,

    S_QBLOCKS = R_STRINGS.source + '|' +
      /(?:\breturn\s+|(?:[$\w\)\]]|\+\+|--)\s*(\/)(?![*\/]))/.source + '|' +
      /\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?(\/)[gim]*/.source,

    FINDBRACES = {
      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),
      '[': RegExp('([[\\]])|' + S_QBLOCKS, REGLOB),
      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)
    },

    DEFAULT = '{ }'

  var _pairs = [
    '{', '}',
    '{', '}',
    /{[^}]*}/,
    /\\([{}])/g,
    /\\({)|{/g,
    RegExp('\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),
    DEFAULT,
    /^\s*{\^?\s*([$\w]+)(?:\s*,\s*(\S+))?\s+in\s+(\S.*)\s*}/,
    /(^|[^\\]){=[\S\s]*?}/
  ]

  var
    cachedBrackets = UNDEF,
    _regex,
    _cache = [],
    _settings

  function _loopback (re) { return re }

  function _rewrite (re, bp) {
    if (!bp) bp = _cache
    return new RegExp(
      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''
    )
  }

  function _create (pair) {
    if (pair === DEFAULT) return _pairs

    var arr = pair.split(' ')

    if (arr.length !== 2 || /[\x00-\x1F<>a-zA-Z0-9'",;\\]/.test(pair)) {
      throw new Error('Unsupported brackets "' + pair + '"')
    }
    arr = arr.concat(pair.replace(/(?=[[\]()*+?.^$|])/g, '\\').split(' '))

    arr[4] = _rewrite(arr[1].length > 1 ? /{[\S\s]*?}/ : _pairs[4], arr)
    arr[5] = _rewrite(pair.length > 3 ? /\\({|})/g : _pairs[5], arr)
    arr[6] = _rewrite(_pairs[6], arr)
    arr[7] = RegExp('\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB)
    arr[8] = pair
    return arr
  }

  function _brackets (reOrIdx) {
    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]
  }

  _brackets.split = function split (str, tmpl, _bp) {
    // istanbul ignore next: _bp is for the compiler
    if (!_bp) _bp = _cache

    var
      parts = [],
      match,
      isexpr,
      start,
      pos,
      re = _bp[6]

    isexpr = start = re.lastIndex = 0

    while ((match = re.exec(str))) {

      pos = match.index

      if (isexpr) {

        if (match[2]) {
          re.lastIndex = skipBraces(str, match[2], re.lastIndex)
          continue
        }
        if (!match[3]) {
          continue
        }
      }

      if (!match[1]) {
        unescapeStr(str.slice(start, pos))
        start = re.lastIndex
        re = _bp[6 + (isexpr ^= 1)]
        re.lastIndex = start
      }
    }

    if (str && start < str.length) {
      unescapeStr(str.slice(start))
    }

    return parts

    function unescapeStr (s) {
      if (tmpl || isexpr) {
        parts.push(s && s.replace(_bp[5], '$1'))
      } else {
        parts.push(s)
      }
    }

    function skipBraces (s, ch, ix) {
      var
        match,
        recch = FINDBRACES[ch]

      recch.lastIndex = ix
      ix = 1
      while ((match = recch.exec(s))) {
        if (match[1] &&
          !(match[1] === ch ? ++ix : --ix)) break
      }
      return ix ? s.length : recch.lastIndex
    }
  }

  _brackets.hasExpr = function hasExpr (str) {
    return _cache[4].test(str)
  }

  _brackets.loopKeys = function loopKeys (expr) {
    var m = expr.match(_cache[9])

    return m
      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }
      : { val: expr.trim() }
  }

  _brackets.array = function array (pair) {
    return pair ? _create(pair) : _cache
  }

  function _reset (pair) {
    if ((pair || (pair = DEFAULT)) !== _cache[8]) {
      _cache = _create(pair)
      _regex = pair === DEFAULT ? _loopback : _rewrite
      _cache[9] = _regex(_pairs[9])
    }
    cachedBrackets = pair
  }

  function _setSettings (o) {
    var b

    o = o || {}
    b = o.brackets
    Object.defineProperty(o, 'brackets', {
      set: _reset,
      get: function () { return cachedBrackets },
      enumerable: true
    })
    _settings = o
    _reset(b)
  }

  Object.defineProperty(_brackets, 'settings', {
    set: _setSettings,
    get: function () { return _settings }
  })

  /* istanbul ignore next: in the browser riot is always in the scope */
  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {}
  _brackets.set = _reset

  _brackets.R_STRINGS = R_STRINGS
  _brackets.R_MLCOMMS = R_MLCOMMS
  _brackets.S_QBLOCKS = S_QBLOCKS

  return _brackets

})()

/**
 * @module tmpl
 *
 * tmpl          - Root function, returns the template value, render with data
 * tmpl.hasExpr  - Test the existence of a expression inside a string
 * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)
 */

var tmpl = (function () {

  var _cache = {}

  function _tmpl (str, data) {
    if (!str) return str

    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)
  }

  _tmpl.haveRaw = brackets.hasRaw

  _tmpl.hasExpr = brackets.hasExpr

  _tmpl.loopKeys = brackets.loopKeys

  _tmpl.errorHandler = null

  function _logErr (err, ctx) {

    if (_tmpl.errorHandler) {

      err.riotData = {
        tagName: ctx && ctx.root && ctx.root.tagName,
        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase
      }
      _tmpl.errorHandler(err)
    }
  }

  function _create (str) {
    var expr = _getTmpl(str)

    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr

    return new Function('E', expr + ';')    //eslint-disable-line no-new-func
  }

  var
    CH_IDEXPR = '\u2057',
    RE_CSNAME = /^(?:(-?[_A-Za-z\xA0-\xFF][-\w\xA0-\xFF]*)|\u2057(\d+)~):/,
    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),
    RE_DQUOTE = /\u2057/g,
    RE_QBMARK = /\u2057(\d+)~/g

  function _getTmpl (str) {
    var
      qstr = [],
      expr,
      parts = brackets.split(str.replace(RE_DQUOTE, '"'), 1)

    if (parts.length > 2 || parts[0]) {
      var i, j, list = []

      for (i = j = 0; i < parts.length; ++i) {

        expr = parts[i]

        if (expr && (expr = i & 1

            ? _parseExpr(expr, 1, qstr)

            : '"' + expr
                .replace(/\\/g, '\\\\')
                .replace(/\r\n?|\n/g, '\\n')
                .replace(/"/g, '\\"') +
              '"'

          )) list[j++] = expr

      }

      expr = j < 2 ? list[0]
           : '[' + list.join(',') + '].join("")'

    } else {

      expr = _parseExpr(parts[1], 0, qstr)
    }

    if (qstr[0]) {
      expr = expr.replace(RE_QBMARK, function (_, pos) {
        return qstr[pos]
          .replace(/\r/g, '\\r')
          .replace(/\n/g, '\\n')
      })
    }
    return expr
  }

  var
    RE_BREND = {
      '(': /[()]/g,
      '[': /[[\]]/g,
      '{': /[{}]/g
    }

  function _parseExpr (expr, asText, qstr) {

    expr = expr
          .replace(RE_QBLOCK, function (s, div) {
            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s
          })
          .replace(/\s+/g, ' ').trim()
          .replace(/\ ?([[\({},?\.:])\ ?/g, '$1')

    if (expr) {
      var
        list = [],
        cnt = 0,
        match

      while (expr &&
            (match = expr.match(RE_CSNAME)) &&
            !match.index
        ) {
        var
          key,
          jsb,
          re = /,|([[{(])|$/g

        expr = RegExp.rightContext
        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\s+/g, ' ') : match[1]

        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re)

        jsb  = expr.slice(0, match.index)
        expr = RegExp.rightContext

        list[cnt++] = _wrapExpr(jsb, 1, key)
      }

      expr = !cnt ? _wrapExpr(expr, asText)
           : cnt > 1 ? '[' + list.join(',') + '].join(" ").trim()' : list[0]
    }
    return expr

    function skipBraces (ch, re) {
      var
        mm,
        lv = 1,
        ir = RE_BREND[ch]

      ir.lastIndex = re.lastIndex
      while (mm = ir.exec(expr)) {
        if (mm[0] === ch) ++lv
        else if (!--lv) break
      }
      re.lastIndex = lv ? expr.length : ir.lastIndex
    }
  }

  // istanbul ignore next: not both
  var // eslint-disable-next-line max-len
    JS_CONTEXT = '"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',
    JS_VARNAME = /[,{][$\w]+:|(^ *|[^$\w\.])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\w]))([$_A-Za-z][$\w]*)/g,
    JS_NOPROPS = /^(?=(\.[$\w]+))\1(?:[^.[(]|$)/

  function _wrapExpr (expr, asText, key) {
    var tb

    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {
      if (mvar) {
        pos = tb ? 0 : pos + match.length

        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {
          match = p + '("' + mvar + JS_CONTEXT + mvar
          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '['
        } else if (pos) {
          tb = !JS_NOPROPS.test(s.slice(pos))
        }
      }
      return match
    })

    if (tb) {
      expr = 'try{return ' + expr + '}catch(e){E(e,this)}'
    }

    if (key) {

      expr = (tb
          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'
        ) + '?"' + key + '":""'

    } else if (asText) {

      expr = 'function(v){' + (tb
          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'
        ) + ';return v||v===0?v:""}.call(this)'
    }

    return expr
  }

  // istanbul ignore next: compatibility fix for beta versions
  _tmpl.parse = function (s) { return s }

  _tmpl.version = brackets.version = 'v2.3.22'

  return _tmpl

})()

/*
  lib/browser/tag/mkdom.js

  Includes hacks needed for the Internet Explorer version 9 and below
  See: http://kangax.github.io/compat-table/es5/#ie8
       http://codeplanet.io/dropping-ie8/
*/
var mkdom = (function _mkdom() {
  var
    reHasYield  = /<yield\b/i,
    reYieldAll  = /<yield\s*(?:\/>|>([\S\s]*?)<\/yield\s*>)/ig,
    reYieldSrc  = /<yield\s+to=['"]([^'">]*)['"]\s*>([\S\s]*?)<\/yield\s*>/ig,
    reYieldDest = /<yield\s+from=['"]?([-\w]+)['"]?\s*(?:\/>|>([\S\s]*?)<\/yield\s*>)/ig
  var
    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },
    tblTags = IE_VERSION && IE_VERSION < 10
      ? SPECIAL_TAGS_REGEX : /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/

  /**
   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be
   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.
   *
   * @param   {string} templ  - The template coming from the custom tag definition
   * @param   {string} [html] - HTML content that comes from the DOM element where you
   *           will mount the tag, mostly the original tag in the page
   * @returns {HTMLElement} DOM element with _templ_ merged through `YIELD` with the _html_.
   */
  function _mkdom(templ, html) {
    var
      match   = templ && templ.match(/^\s*<([-\w]+)/),
      tagName = match && match[1].toLowerCase(),
      el = mkEl('div')

    // replace all the yield tags with the tag inner html
    templ = replaceYield(templ, html)

    /* istanbul ignore next */
    if (tblTags.test(tagName))
      el = specialTags(el, templ, tagName)
    else
      el.innerHTML = templ

    el.stub = true

    return el
  }

  /*
    Creates the root element for table or select child elements:
    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup
  */
  function specialTags(el, templ, tagName) {
    var
      select = tagName[0] === 'o',
      parent = select ? 'select>' : 'table>'

    // trim() is important here, this ensures we don't have artifacts,
    // so we can check if we have only one element inside the parent
    el.innerHTML = '<' + parent + templ.trim() + '</' + parent
    parent = el.firstChild

    // returns the immediate parent if tr/th/td/col is the only element, if not
    // returns the whole tree, as this can include additional elements
    if (select) {
      parent.selectedIndex = -1  // for IE9, compatible w/current riot behavior
    } else {
      // avoids insertion of cointainer inside container (ex: tbody inside tbody)
      var tname = rootEls[tagName]
      if (tname && parent.childElementCount === 1) parent = $(tname, parent)
    }
    return parent
  }

  /*
    Replace the yield tag from any tag template with the innerHTML of the
    original tag in the page
  */
  function replaceYield(templ, html) {
    // do nothing if no yield
    if (!reHasYield.test(templ)) return templ

    // be careful with #1343 - string on the source having `$1`
    var src = {}

    html = html && html.replace(reYieldSrc, function (_, ref, text) {
      src[ref] = src[ref] || text   // preserve first definition
      return ''
    }).trim()

    return templ
      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs
        return src[ref] || def || ''
      })
      .replace(reYieldAll, function (_, def) {        // yield without any "from"
        return html || def || ''
      })
  }

  return _mkdom

})()

/**
 * Convert the item looped into an object used to extend the child tag properties
 * @param   { Object } expr - object containing the keys used to extend the children tags
 * @param   { * } key - value to assign to the new object returned
 * @param   { * } val - value containing the position of the item in the array
 * @returns { Object } - new object containing the values of the original item
 *
 * The variables 'key' and 'val' are arbitrary.
 * They depend on the collection type looped (Array, Object)
 * and on the expression used on the each tag
 *
 */
function mkitem(expr, key, val) {
  var item = {}
  item[expr.key] = key
  if (expr.pos) item[expr.pos] = val
  return item
}

/**
 * Unmount the redundant tags
 * @param   { Array } items - array containing the current items to loop
 * @param   { Array } tags - array containing all the children tags
 */
function unmountRedundant(items, tags) {

  var i = tags.length,
    j = items.length,
    t

  while (i > j) {
    t = tags[--i]
    tags.splice(i, 1)
    t.unmount()
  }
}

/**
 * Move the nested custom tags in non custom loop tags
 * @param   { Object } child - non custom loop tag
 * @param   { Number } i - current position of the loop tag
 */
function moveNestedTags(child, i) {
  Object.keys(child.tags).forEach(function(tagName) {
    var tag = child.tags[tagName]
    if (isArray(tag))
      each(tag, function (t) {
        moveChildTag(t, tagName, i)
      })
    else
      moveChildTag(tag, tagName, i)
  })
}

/**
 * Adds the elements for a virtual tag
 * @param { Tag } tag - the tag whose root's children will be inserted or appended
 * @param { Node } src - the node that will do the inserting or appending
 * @param { Tag } target - only if inserting, insert before this tag's first child
 */
function addVirtual(tag, src, target) {
  var el = tag._root, sib
  tag._virts = []
  while (el) {
    sib = el.nextSibling
    if (target)
      src.insertBefore(el, target._root)
    else
      src.appendChild(el)

    tag._virts.push(el) // hold for unmounting
    el = sib
  }
}

/**
 * Move virtual tag and all child nodes
 * @param { Tag } tag - first child reference used to start move
 * @param { Node } src  - the node that will do the inserting
 * @param { Tag } target - insert before this tag's first child
 * @param { Number } len - how many child nodes to move
 */
function moveVirtual(tag, src, target, len) {
  var el = tag._root, sib, i = 0
  for (; i < len; i++) {
    sib = el.nextSibling
    src.insertBefore(el, target._root)
    el = sib
  }
}


/**
 * Manage tags having the 'each'
 * @param   { Object } dom - DOM node we need to loop
 * @param   { Tag } parent - parent tag instance where the dom node is contained
 * @param   { String } expr - string contained in the 'each' attribute
 */
function _each(dom, parent, expr) {

  // remove the each property from the original tag
  remAttr(dom, 'each')

  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),
    tagName = getTagName(dom),
    impl = __tagImpl[tagName] || { tmpl: dom.outerHTML },
    useRoot = SPECIAL_TAGS_REGEX.test(tagName),
    root = dom.parentNode,
    ref = document.createTextNode(''),
    child = getTag(dom),
    isOption = tagName.toLowerCase() === 'option', // the option tags must be treated differently
    tags = [],
    oldItems = [],
    hasKeys,
    isVirtual = dom.tagName == 'VIRTUAL'

  // parse the each expression
  expr = tmpl.loopKeys(expr)

  // insert a marked where the loop tags will be injected
  root.insertBefore(ref, dom)

  // clean template code
  parent.one('before-mount', function () {

    // remove the original DOM node
    dom.parentNode.removeChild(dom)
    if (root.stub) root = parent.root

  }).on('update', function () {
    // get the new items collection
    var items = tmpl(expr.val, parent),
      // create a fragment to hold the new DOM nodes to inject in the parent tag
      frag = document.createDocumentFragment()

    // object loop. any changes cause full redraw
    if (!isArray(items)) {
      hasKeys = items || false
      items = hasKeys ?
        Object.keys(items).map(function (key) {
          return mkitem(expr, key, items[key])
        }) : []
    }

    // loop all the new items
    var i = 0,
      itemsLength = items.length

    for (; i < itemsLength; i++) {
      // reorder only if the items are objects
      var
        item = items[i],
        _mustReorder = mustReorder && item instanceof Object && !hasKeys,
        oldPos = oldItems.indexOf(item),
        pos = ~oldPos && _mustReorder ? oldPos : i,
        // does a tag exist in this position?
        tag = tags[pos]

      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item

      // new tag
      if (
        !_mustReorder && !tag // with no-reorder we just update the old tags
        ||
        _mustReorder && !~oldPos || !tag // by default we always try to reorder the DOM elements
      ) {

        tag = new Tag(impl, {
          parent: parent,
          isLoop: true,
          hasImpl: !!__tagImpl[tagName],
          root: useRoot ? root : dom.cloneNode(),
          item: item
        }, dom.innerHTML)

        tag.mount()

        if (isVirtual) tag._root = tag.root.firstChild // save reference for further moves or inserts
        // this tag must be appended
        if (i == tags.length || !tags[i]) { // fix 1581
          if (isVirtual)
            addVirtual(tag, frag)
          else frag.appendChild(tag.root)
        }
        // this tag must be insert
        else {
          if (isVirtual)
            addVirtual(tag, root, tags[i])
          else root.insertBefore(tag.root, tags[i].root) // #1374 some browsers reset selected here
          oldItems.splice(i, 0, item)
        }

        tags.splice(i, 0, tag)
        pos = i // handled here so no move
      } else tag.update(item, true)

      // reorder the tag if it's not located in its previous position
      if (
        pos !== i && _mustReorder &&
        tags[i] // fix 1581 unable to reproduce it in a test!
      ) {
        // update the DOM
        if (isVirtual)
          moveVirtual(tag, root, tags[i], dom.childNodes.length)
        else root.insertBefore(tag.root, tags[i].root)
        // update the position attribute if it exists
        if (expr.pos)
          tag[expr.pos] = i
        // move the old tag instance
        tags.splice(i, 0, tags.splice(pos, 1)[0])
        // move the old item
        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0])
        // if the loop tags are not custom
        // we need to move all their custom tags into the right position
        if (!child && tag.tags) moveNestedTags(tag, i)
      }

      // cache the original item to use it in the events bound to this node
      // and its children
      tag._item = item
      // cache the real parent tag internally
      defineProperty(tag, '_parent', parent)
    }

    // remove the redundant tags
    unmountRedundant(items, tags)

    // insert the new nodes
    if (isOption) {
      root.appendChild(frag)

      // #1374 FireFox bug in <option selected={expression}>
      if (FIREFOX && !root.multiple) {
        for (var n = 0; n < root.length; n++) {
          if (root[n].__riot1374) {
            root.selectedIndex = n  // clear other options
            delete root[n].__riot1374
            break
          }
        }
      }
    }
    else root.insertBefore(frag, ref)

    // set the 'tags' property of the parent tag
    // if child is 'undefined' it means that we don't need to set this property
    // for example:
    // we don't need store the `myTag.tags['div']` property if we are looping a div tag
    // but we need to track the `myTag.tags['child']` property looping a custom child node named `child`
    if (child) parent.tags[tagName] = tags

    // clone the items array
    oldItems = items.slice()

  })

}
/**
 * Object that will be used to inject and manage the css of every tag instance
 */
var styleManager = (function(_riot) {

  if (!window) return { // skip injection on the server
    add: function () {},
    inject: function () {}
  }

  var styleNode = (function () {
    // create a new style element with the correct type
    var newNode = mkEl('style')
    setAttr(newNode, 'type', 'text/css')

    // replace any user node or insert the new one into the head
    var userNode = $('style[type=riot]')
    if (userNode) {
      if (userNode.id) newNode.id = userNode.id
      userNode.parentNode.replaceChild(newNode, userNode)
    }
    else document.getElementsByTagName('head')[0].appendChild(newNode)

    return newNode
  })()

  // Create cache and shortcut to the correct property
  var cssTextProp = styleNode.styleSheet,
    stylesToInject = ''

  // Expose the style node in a non-modificable property
  Object.defineProperty(_riot, 'styleNode', {
    value: styleNode,
    writable: true
  })

  /**
   * Public api
   */
  return {
    /**
     * Save a tag style to be later injected into DOM
     * @param   { String } css [description]
     */
    add: function(css) {
      stylesToInject += css
    },
    /**
     * Inject all previously saved tag styles into DOM
     * innerHTML seems slow: http://jsperf.com/riot-insert-style
     */
    inject: function() {
      if (stylesToInject) {
        if (cssTextProp) cssTextProp.cssText += stylesToInject
        else styleNode.innerHTML += stylesToInject
        stylesToInject = ''
      }
    }
  }

})(riot)


function parseNamedElements(root, tag, childTags, forceParsingNamed) {

  walk(root, function(dom) {
    if (dom.nodeType == 1) {
      dom.isLoop = dom.isLoop ||
                  (dom.parentNode && dom.parentNode.isLoop || getAttr(dom, 'each'))
                    ? 1 : 0

      // custom child tag
      if (childTags) {
        var child = getTag(dom)

        if (child && !dom.isLoop)
          childTags.push(initChildTag(child, {root: dom, parent: tag}, dom.innerHTML, tag))
      }

      if (!dom.isLoop || forceParsingNamed)
        setNamed(dom, tag, [])
    }

  })

}

function parseExpressions(root, tag, expressions) {

  function addExpr(dom, val, extra) {
    if (tmpl.hasExpr(val)) {
      expressions.push(extend({ dom: dom, expr: val }, extra))
    }
  }

  walk(root, function(dom) {
    var type = dom.nodeType,
      attr

    // text node
    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)
    if (type != 1) return

    /* element */

    // loop
    attr = getAttr(dom, 'each')

    if (attr) { _each(dom, tag, attr); return false }

    // attribute expressions
    each(dom.attributes, function(attr) {
      var name = attr.name,
        bool = name.split('__')[1]

      addExpr(dom, attr.value, { attr: bool || name, bool: bool })
      if (bool) { remAttr(dom, name); return false }

    })

    // skip custom tags
    if (getTag(dom)) return false

  })

}
function Tag(impl, conf, innerHTML) {

  var self = riot.observable(this),
    opts = inherit(conf.opts) || {},
    parent = conf.parent,
    isLoop = conf.isLoop,
    hasImpl = conf.hasImpl,
    item = cleanUpData(conf.item),
    expressions = [],
    childTags = [],
    root = conf.root,
    tagName = root.tagName.toLowerCase(),
    attr = {},
    propsInSyncWithParent = [],
    dom

  // only call unmount if we have a valid __tagImpl (has name property)
  if (impl.name && root._tag) root._tag.unmount(true)

  // not yet mounted
  this.isMounted = false
  root.isLoop = isLoop

  // keep a reference to the tag just created
  // so we will be able to mount this tag multiple times
  root._tag = this

  // create a unique id to this tag
  // it could be handy to use it also to improve the virtual dom rendering speed
  defineProperty(this, '_riot_id', ++__uid) // base 1 allows test !t._riot_id

  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)

  // grab attributes
  each(root.attributes, function(el) {
    var val = el.value
    // remember attributes with expressions only
    if (tmpl.hasExpr(val)) attr[el.name] = val
  })

  dom = mkdom(impl.tmpl, innerHTML)

  // options
  function updateOpts() {
    var ctx = hasImpl && isLoop ? self : parent || self

    // update opts from current DOM attributes
    each(root.attributes, function(el) {
      var val = el.value
      opts[toCamel(el.name)] = tmpl.hasExpr(val) ? tmpl(val, ctx) : val
    })
    // recover those with expressions
    each(Object.keys(attr), function(name) {
      opts[toCamel(name)] = tmpl(attr[name], ctx)
    })
  }

  function normalizeData(data) {
    for (var key in item) {
      if (typeof self[key] !== T_UNDEF && isWritable(self, key))
        self[key] = data[key]
    }
  }

  function inheritFromParent () {
    if (!self.parent || !isLoop) return
    each(Object.keys(self.parent), function(k) {
      // some properties must be always in sync with the parent tag
      var mustSync = !contains(RESERVED_WORDS_BLACKLIST, k) && contains(propsInSyncWithParent, k)
      if (typeof self[k] === T_UNDEF || mustSync) {
        // track the property to keep in sync
        // so we can keep it updated
        if (!mustSync) propsInSyncWithParent.push(k)
        self[k] = self.parent[k]
      }
    })
  }

  /**
   * Update the tag expressions and options
   * @param   { * }  data - data we want to use to extend the tag properties
   * @param   { Boolean } isInherited - is this update coming from a parent tag?
   * @returns { self }
   */
  defineProperty(this, 'update', function(data, isInherited) {

    // make sure the data passed will not override
    // the component core methods
    data = cleanUpData(data)
    // inherit properties from the parent
    inheritFromParent()
    // normalize the tag properties in case an item object was initially passed
    if (data && isObject(item)) {
      normalizeData(data)
      item = data
    }
    extend(self, data)
    updateOpts()
    self.trigger('update', data)
    update(expressions, self)

    // the updated event will be triggered
    // once the DOM will be ready and all the re-flows are completed
    // this is useful if you want to get the "real" root properties
    // 4 ex: root.offsetWidth ...
    if (isInherited && self.parent)
      // closes #1599
      self.parent.one('updated', function() { self.trigger('updated') })
    else rAF(function() { self.trigger('updated') })

    return this
  })

  defineProperty(this, 'mixin', function() {
    each(arguments, function(mix) {
      var instance

      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix

      // check if the mixin is a function
      if (isFunction(mix)) {
        // create the new mixin instance
        instance = new mix()
        // save the prototype to loop it afterwards
        mix = mix.prototype
      } else instance = mix

      // loop the keys in the function prototype or the all object keys
      each(Object.getOwnPropertyNames(mix), function(key) {
        // bind methods to self
        if (key != 'init')
          self[key] = isFunction(instance[key]) ?
                        instance[key].bind(self) :
                        instance[key]
      })

      // init method will be called automatically
      if (instance.init) instance.init.bind(self)()
    })
    return this
  })

  defineProperty(this, 'mount', function() {

    updateOpts()

    // add global mixin
    var globalMixin = riot.mixin(GLOBAL_MIXIN)
    if (globalMixin) self.mixin(globalMixin)

    // initialiation
    if (impl.fn) impl.fn.call(self, opts)

    // parse layout after init. fn may calculate args for nested custom tags
    parseExpressions(dom, self, expressions)

    // mount the child tags
    toggle(true)

    // update the root adding custom attributes coming from the compiler
    // it fixes also #1087
    if (impl.attrs)
      walkAttributes(impl.attrs, function (k, v) { setAttr(root, k, v) })
    if (impl.attrs || hasImpl)
      parseExpressions(self.root, self, expressions)

    if (!self.parent || isLoop) self.update(item)

    // internal use only, fixes #403
    self.trigger('before-mount')

    if (isLoop && !hasImpl) {
      // update the root attribute for the looped elements
      root = dom.firstChild
    } else {
      while (dom.firstChild) root.appendChild(dom.firstChild)
      if (root.stub) root = parent.root
    }

    defineProperty(self, 'root', root)

    // parse the named dom nodes in the looped child
    // adding them to the parent as well
    if (isLoop)
      parseNamedElements(self.root, self.parent, null, true)

    // if it's not a child tag we can trigger its mount event
    if (!self.parent || self.parent.isMounted) {
      self.isMounted = true
      self.trigger('mount')
    }
    // otherwise we need to wait that the parent event gets triggered
    else self.parent.one('mount', function() {
      // avoid to trigger the `mount` event for the tags
      // not visible included in an if statement
      if (!isInStub(self.root)) {
        self.parent.isMounted = self.isMounted = true
        self.trigger('mount')
      }
    })
  })


  defineProperty(this, 'unmount', function(keepRootTag) {
    var el = root,
      p = el.parentNode,
      ptag,
      tagIndex = __virtualDom.indexOf(self)

    self.trigger('before-unmount')

    // remove this tag instance from the global virtualDom variable
    if (~tagIndex)
      __virtualDom.splice(tagIndex, 1)

    if (p) {

      if (parent) {
        ptag = getImmediateCustomParentTag(parent)
        // remove this tag from the parent tags object
        // if there are multiple nested tags with same name..
        // remove this element form the array
        if (isArray(ptag.tags[tagName]))
          each(ptag.tags[tagName], function(tag, i) {
            if (tag._riot_id == self._riot_id)
              ptag.tags[tagName].splice(i, 1)
          })
        else
          // otherwise just delete the tag instance
          ptag.tags[tagName] = undefined
      }

      else
        while (el.firstChild) el.removeChild(el.firstChild)

      if (!keepRootTag)
        p.removeChild(el)
      else {
        // the riot-tag and the data-is attributes aren't needed anymore, remove them
        remAttr(p, RIOT_TAG_IS)
        remAttr(p, RIOT_TAG) // this will be removed in riot 3.0.0
      }

    }

    if (this._virts) {
      each(this._virts, function(v) {
        if (v.parentNode) v.parentNode.removeChild(v)
      })
    }

    self.trigger('unmount')
    toggle()
    self.off('*')
    self.isMounted = false
    delete root._tag

  })

  // proxy function to bind updates
  // dispatched from a parent tag
  function onChildUpdate(data) { self.update(data, true) }

  function toggle(isMount) {

    // mount/unmount children
    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })

    // listen/unlisten parent (events flow one way from parent to children)
    if (!parent) return
    var evt = isMount ? 'on' : 'off'

    // the loop tags will be always in sync with the parent automatically
    if (isLoop)
      parent[evt]('unmount', self.unmount)
    else {
      parent[evt]('update', onChildUpdate)[evt]('unmount', self.unmount)
    }
  }


  // named elements available for fn
  parseNamedElements(dom, this, childTags)

}
/**
 * Attach an event to a DOM node
 * @param { String } name - event name
 * @param { Function } handler - event callback
 * @param { Object } dom - dom node
 * @param { Tag } tag - tag instance
 */
function setEventHandler(name, handler, dom, tag) {

  dom[name] = function(e) {

    var ptag = tag._parent,
      item = tag._item,
      el

    if (!item)
      while (ptag && !item) {
        item = ptag._item
        ptag = ptag._parent
      }

    // cross browser event fix
    e = e || window.event

    // override the event properties
    if (isWritable(e, 'currentTarget')) e.currentTarget = dom
    if (isWritable(e, 'target')) e.target = e.srcElement
    if (isWritable(e, 'which')) e.which = e.charCode || e.keyCode

    e.item = item

    // prevent default behaviour (by default)
    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {
      if (e.preventDefault) e.preventDefault()
      e.returnValue = false
    }

    if (!e.preventUpdate) {
      el = item ? getImmediateCustomParentTag(ptag) : tag
      el.update()
    }

  }

}


/**
 * Insert a DOM node replacing another one (used by if- attribute)
 * @param   { Object } root - parent node
 * @param   { Object } node - node replaced
 * @param   { Object } before - node added
 */
function insertTo(root, node, before) {
  if (!root) return
  root.insertBefore(before, node)
  root.removeChild(node)
}

/**
 * Update the expressions in a Tag instance
 * @param   { Array } expressions - expression that must be re evaluated
 * @param   { Tag } tag - tag instance
 */
function update(expressions, tag) {

  each(expressions, function(expr, i) {

    var dom = expr.dom,
      attrName = expr.attr,
      value = tmpl(expr.expr, tag),
      parent = expr.dom.parentNode

    if (expr.bool) {
      value = !!value
    } else if (value == null) {
      value = ''
    }

    // #1638: regression of #1612, update the dom only if the value of the
    // expression was changed
    if (expr.value === value) {
      return
    }
    expr.value = value

    // textarea and text nodes has no attribute name
    if (!attrName) {
      // about #815 w/o replace: the browser converts the value to a string,
      // the comparison by "==" does too, but not in the server
      value += ''
      // test for parent avoids error with invalid assignment to nodeValue
      if (parent) {
        if (parent.tagName === 'TEXTAREA') {
          parent.value = value                    // #1113
          if (!IE_VERSION) dom.nodeValue = value  // #1625 IE throws here, nodeValue
        }                                         // will be available on 'updated'
        else dom.nodeValue = value
      }
      return
    }

    // ~~#1612: look for changes in dom.value when updating the value~~
    if (attrName === 'value') {
      dom.value = value
      return
    }

    // remove original attribute
    remAttr(dom, attrName)

    // event handler
    if (isFunction(value)) {
      setEventHandler(attrName, value, dom, tag)

    // if- conditional
    } else if (attrName == 'if') {
      var stub = expr.stub,
        add = function() { insertTo(stub.parentNode, stub, dom) },
        remove = function() { insertTo(dom.parentNode, dom, stub) }

      // add to DOM
      if (value) {
        if (stub) {
          add()
          dom.inStub = false
          // avoid to trigger the mount event if the tags is not visible yet
          // maybe we can optimize this avoiding to mount the tag at all
          if (!isInStub(dom)) {
            walk(dom, function(el) {
              if (el._tag && !el._tag.isMounted)
                el._tag.isMounted = !!el._tag.trigger('mount')
            })
          }
        }
      // remove from DOM
      } else {
        stub = expr.stub = stub || document.createTextNode('')
        // if the parentNode is defined we can easily replace the tag
        if (dom.parentNode)
          remove()
        // otherwise we need to wait the updated event
        else (tag.parent || tag).one('updated', remove)

        dom.inStub = true
      }
    // show / hide
    } else if (attrName === 'show') {
      dom.style.display = value ? '' : 'none'

    } else if (attrName === 'hide') {
      dom.style.display = value ? 'none' : ''

    } else if (expr.bool) {
      dom[attrName] = value
      if (value) setAttr(dom, attrName, attrName)
      if (FIREFOX && attrName === 'selected' && dom.tagName === 'OPTION') {
        dom.__riot1374 = value   // #1374
      }

    } else if (value === 0 || value && typeof value !== T_OBJECT) {
      // <img src="{ expr }">
      if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {
        attrName = attrName.slice(RIOT_PREFIX.length)
      }
      setAttr(dom, attrName, value)
    }

  })

}
/**
 * Specialized function for looping an array-like collection with `each={}`
 * @param   { Array } els - collection of items
 * @param   {Function} fn - callback function
 * @returns { Array } the array looped
 */
function each(els, fn) {
  var len = els ? els.length : 0

  for (var i = 0, el; i < len; i++) {
    el = els[i]
    // return false -> current item was removed by fn during the loop
    if (el != null && fn(el, i) === false) i--
  }
  return els
}

/**
 * Detect if the argument passed is a function
 * @param   { * } v - whatever you want to pass to this function
 * @returns { Boolean } -
 */
function isFunction(v) {
  return typeof v === T_FUNCTION || false   // avoid IE problems
}

/**
 * Detect if the argument passed is an object, exclude null.
 * NOTE: Use isObject(x) && !isArray(x) to excludes arrays.
 * @param   { * } v - whatever you want to pass to this function
 * @returns { Boolean } -
 */
function isObject(v) {
  return v && typeof v === T_OBJECT         // typeof null is 'object'
}

/**
 * Remove any DOM attribute from a node
 * @param   { Object } dom - DOM node we want to update
 * @param   { String } name - name of the property we want to remove
 */
function remAttr(dom, name) {
  dom.removeAttribute(name)
}

/**
 * Convert a string containing dashes to camel case
 * @param   { String } string - input string
 * @returns { String } my-string -> myString
 */
function toCamel(string) {
  return string.replace(/-(\w)/g, function(_, c) {
    return c.toUpperCase()
  })
}

/**
 * Get the value of any DOM attribute on a node
 * @param   { Object } dom - DOM node we want to parse
 * @param   { String } name - name of the attribute we want to get
 * @returns { String | undefined } name of the node attribute whether it exists
 */
function getAttr(dom, name) {
  return dom.getAttribute(name)
}

/**
 * Set any DOM attribute
 * @param { Object } dom - DOM node we want to update
 * @param { String } name - name of the property we want to set
 * @param { String } val - value of the property we want to set
 */
function setAttr(dom, name, val) {
  dom.setAttribute(name, val)
}

/**
 * Detect the tag implementation by a DOM node
 * @param   { Object } dom - DOM node we need to parse to get its tag implementation
 * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)
 */
function getTag(dom) {
  return dom.tagName && __tagImpl[getAttr(dom, RIOT_TAG_IS) ||
    getAttr(dom, RIOT_TAG) || dom.tagName.toLowerCase()]
}
/**
 * Add a child tag to its parent into the `tags` object
 * @param   { Object } tag - child tag instance
 * @param   { String } tagName - key where the new tag will be stored
 * @param   { Object } parent - tag instance where the new child tag will be included
 */
function addChildTag(tag, tagName, parent) {
  var cachedTag = parent.tags[tagName]

  // if there are multiple children tags having the same name
  if (cachedTag) {
    // if the parent tags property is not yet an array
    // create it adding the first cached tag
    if (!isArray(cachedTag))
      // don't add the same tag twice
      if (cachedTag !== tag)
        parent.tags[tagName] = [cachedTag]
    // add the new nested tag to the array
    if (!contains(parent.tags[tagName], tag))
      parent.tags[tagName].push(tag)
  } else {
    parent.tags[tagName] = tag
  }
}

/**
 * Move the position of a custom tag in its parent tag
 * @param   { Object } tag - child tag instance
 * @param   { String } tagName - key where the tag was stored
 * @param   { Number } newPos - index where the new tag will be stored
 */
function moveChildTag(tag, tagName, newPos) {
  var parent = tag.parent,
    tags
  // no parent no move
  if (!parent) return

  tags = parent.tags[tagName]

  if (isArray(tags))
    tags.splice(newPos, 0, tags.splice(tags.indexOf(tag), 1)[0])
  else addChildTag(tag, tagName, parent)
}

/**
 * Create a new child tag including it correctly into its parent
 * @param   { Object } child - child tag implementation
 * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted
 * @param   { String } innerHTML - inner html of the child node
 * @param   { Object } parent - instance of the parent tag including the child custom tag
 * @returns { Object } instance of the new child tag just created
 */
function initChildTag(child, opts, innerHTML, parent) {
  var tag = new Tag(child, opts, innerHTML),
    tagName = getTagName(opts.root),
    ptag = getImmediateCustomParentTag(parent)
  // fix for the parent attribute in the looped elements
  tag.parent = ptag
  // store the real parent tag
  // in some cases this could be different from the custom parent tag
  // for example in nested loops
  tag._parent = parent

  // add this tag to the custom parent tag
  addChildTag(tag, tagName, ptag)
  // and also to the real parent tag
  if (ptag !== parent)
    addChildTag(tag, tagName, parent)
  // empty the child node once we got its template
  // to avoid that its children get compiled multiple times
  opts.root.innerHTML = ''

  return tag
}

/**
 * Loop backward all the parents tree to detect the first custom parent tag
 * @param   { Object } tag - a Tag instance
 * @returns { Object } the instance of the first custom parent tag found
 */
function getImmediateCustomParentTag(tag) {
  var ptag = tag
  while (!getTag(ptag.root)) {
    if (!ptag.parent) break
    ptag = ptag.parent
  }
  return ptag
}

/**
 * Helper function to set an immutable property
 * @param   { Object } el - object where the new property will be set
 * @param   { String } key - object key where the new property will be stored
 * @param   { * } value - value of the new property
* @param   { Object } options - set the propery overriding the default options
 * @returns { Object } - the initial object
 */
function defineProperty(el, key, value, options) {
  Object.defineProperty(el, key, extend({
    value: value,
    enumerable: false,
    writable: false,
    configurable: true
  }, options))
  return el
}

/**
 * Get the tag name of any DOM node
 * @param   { Object } dom - DOM node we want to parse
 * @returns { String } name to identify this dom node in riot
 */
function getTagName(dom) {
  var child = getTag(dom),
    namedTag = getAttr(dom, 'name'),
    tagName = namedTag && !tmpl.hasExpr(namedTag) ?
                namedTag :
              child ? child.name : dom.tagName.toLowerCase()

  return tagName
}

/**
 * Extend any object with other properties
 * @param   { Object } src - source object
 * @returns { Object } the resulting extended object
 *
 * var obj = { foo: 'baz' }
 * extend(obj, {bar: 'bar', foo: 'bar'})
 * console.log(obj) => {bar: 'bar', foo: 'bar'}
 *
 */
function extend(src) {
  var obj, args = arguments
  for (var i = 1; i < args.length; ++i) {
    if (obj = args[i]) {
      for (var key in obj) {
        // check if this property of the source object could be overridden
        if (isWritable(src, key))
          src[key] = obj[key]
      }
    }
  }
  return src
}

/**
 * Check whether an array contains an item
 * @param   { Array } arr - target array
 * @param   { * } item - item to test
 * @returns { Boolean } Does 'arr' contain 'item'?
 */
function contains(arr, item) {
  return ~arr.indexOf(item)
}

/**
 * Check whether an object is a kind of array
 * @param   { * } a - anything
 * @returns {Boolean} is 'a' an array?
 */
function isArray(a) { return Array.isArray(a) || a instanceof Array }

/**
 * Detect whether a property of an object could be overridden
 * @param   { Object }  obj - source object
 * @param   { String }  key - object property
 * @returns { Boolean } is this property writable?
 */
function isWritable(obj, key) {
  var props = Object.getOwnPropertyDescriptor(obj, key)
  return typeof obj[key] === T_UNDEF || props && props.writable
}


/**
 * With this function we avoid that the internal Tag methods get overridden
 * @param   { Object } data - options we want to use to extend the tag instance
 * @returns { Object } clean object without containing the riot internal reserved words
 */
function cleanUpData(data) {
  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION))
    return data

  var o = {}
  for (var key in data) {
    if (!contains(RESERVED_WORDS_BLACKLIST, key))
      o[key] = data[key]
  }
  return o
}

/**
 * Walk down recursively all the children tags starting dom node
 * @param   { Object }   dom - starting node where we will start the recursion
 * @param   { Function } fn - callback to transform the child node just found
 */
function walk(dom, fn) {
  if (dom) {
    // stop the recursion
    if (fn(dom) === false) return
    else {
      dom = dom.firstChild

      while (dom) {
        walk(dom, fn)
        dom = dom.nextSibling
      }
    }
  }
}

/**
 * Minimize risk: only zero or one _space_ between attr & value
 * @param   { String }   html - html string we want to parse
 * @param   { Function } fn - callback function to apply on any attribute found
 */
function walkAttributes(html, fn) {
  var m,
    re = /([-\w]+) ?= ?(?:"([^"]*)|'([^']*)|({[^}]*}))/g

  while (m = re.exec(html)) {
    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])
  }
}

/**
 * Check whether a DOM node is in stub mode, useful for the riot 'if' directive
 * @param   { Object }  dom - DOM node we want to parse
 * @returns { Boolean } -
 */
function isInStub(dom) {
  while (dom) {
    if (dom.inStub) return true
    dom = dom.parentNode
  }
  return false
}

/**
 * Create a generic DOM node
 * @param   { String } name - name of the DOM node we want to create
 * @returns { Object } DOM node just created
 */
function mkEl(name) {
  return document.createElement(name)
}

/**
 * Shorter and fast way to select multiple nodes in the DOM
 * @param   { String } selector - DOM selector
 * @param   { Object } ctx - DOM node where the targets of our search will is located
 * @returns { Object } dom nodes found
 */
function $$(selector, ctx) {
  return (ctx || document).querySelectorAll(selector)
}

/**
 * Shorter and fast way to select a single node in the DOM
 * @param   { String } selector - unique dom selector
 * @param   { Object } ctx - DOM node where the target of our search will is located
 * @returns { Object } dom node found
 */
function $(selector, ctx) {
  return (ctx || document).querySelector(selector)
}

/**
 * Simple object prototypal inheritance
 * @param   { Object } parent - parent object
 * @returns { Object } child instance
 */
function inherit(parent) {
  function Child() {}
  Child.prototype = parent
  return new Child()
}

/**
 * Get the name property needed to identify a DOM node in riot
 * @param   { Object } dom - DOM node we need to parse
 * @returns { String | undefined } give us back a string to identify this dom node
 */
function getNamedKey(dom) {
  return getAttr(dom, 'id') || getAttr(dom, 'name')
}

/**
 * Set the named properties of a tag element
 * @param { Object } dom - DOM node we need to parse
 * @param { Object } parent - tag instance where the named dom element will be eventually added
 * @param { Array } keys - list of all the tag instance properties
 */
function setNamed(dom, parent, keys) {
  // get the key value we want to add to the tag instance
  var key = getNamedKey(dom),
    isArr,
    // add the node detected to a tag instance using the named property
    add = function(value) {
      // avoid to override the tag properties already set
      if (contains(keys, key)) return
      // check whether this value is an array
      isArr = isArray(value)
      // if the key was never set
      if (!value)
        // set it once on the tag instance
        parent[key] = dom
      // if it was an array and not yet set
      else if (!isArr || isArr && !contains(value, dom)) {
        // add the dom node into the array
        if (isArr)
          value.push(dom)
        else
          parent[key] = [value, dom]
      }
    }

  // skip the elements with no named properties
  if (!key) return

  // check whether this key has been already evaluated
  if (tmpl.hasExpr(key))
    // wait the first updated event only once
    parent.one('mount', function() {
      key = getNamedKey(dom)
      add(parent[key])
    })
  else
    add(parent[key])

}

/**
 * Faster String startsWith alternative
 * @param   { String } src - source string
 * @param   { String } str - test string
 * @returns { Boolean } -
 */
function startsWith(src, str) {
  return src.slice(0, str.length) === str
}

/**
 * requestAnimationFrame function
 * Adapted from https://gist.github.com/paulirish/1579671, license MIT
 */
var rAF = (function (w) {
  var raf = w.requestAnimationFrame    ||
            w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame

  if (!raf || /iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent)) {  // buggy iOS6
    var lastTime = 0

    raf = function (cb) {
      var nowtime = Date.now(), timeout = Math.max(16 - (nowtime - lastTime), 0)
      setTimeout(function () { cb(lastTime = nowtime + timeout) }, timeout)
    }
  }
  return raf

})(window || {})

/**
 * Mount a tag creating new Tag instance
 * @param   { Object } root - dom node where the tag will be mounted
 * @param   { String } tagName - name of the riot tag we want to mount
 * @param   { Object } opts - options to pass to the Tag instance
 * @returns { Tag } a new Tag instance
 */
function mountTo(root, tagName, opts) {
  var tag = __tagImpl[tagName],
    // cache the inner HTML to fix #855
    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML

  // clear the inner html
  root.innerHTML = ''

  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)

  if (tag && tag.mount) {
    tag.mount()
    // add this tag to the virtualDom variable
    if (!contains(__virtualDom, tag)) __virtualDom.push(tag)
  }

  return tag
}
/**
 * Riot public api
 */

// share methods for other riot parts, e.g. compiler
riot.util = { brackets: brackets, tmpl: tmpl }

/**
 * Create a mixin that could be globally shared across all the tags
 */
riot.mixin = (function() {
  var mixins = {}

  /**
   * Create/Return a mixin by its name
   * @param   { String } name - mixin name (global mixin if missing)
   * @param   { Object } mixin - mixin logic
   * @returns { Object } the mixin logic
   */
  return function(name, mixin) {
    if (isObject(name)) {
      mixin = name
      mixins[GLOBAL_MIXIN] = extend(mixins[GLOBAL_MIXIN] || {}, mixin)
      return
    }

    if (!mixin) return mixins[name]
    mixins[name] = mixin
  }

})()

/**
 * Create a new riot tag implementation
 * @param   { String }   name - name/id of the new riot tag
 * @param   { String }   html - tag template
 * @param   { String }   css - custom tag css
 * @param   { String }   attrs - root tag attributes
 * @param   { Function } fn - user function
 * @returns { String } name/id of the tag just created
 */
riot.tag = function(name, html, css, attrs, fn) {
  if (isFunction(attrs)) {
    fn = attrs
    if (/^[\w\-]+\s?=/.test(css)) {
      attrs = css
      css = ''
    } else attrs = ''
  }
  if (css) {
    if (isFunction(css)) fn = css
    else styleManager.add(css)
  }
  name = name.toLowerCase()
  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }
  return name
}

/**
 * Create a new riot tag implementation (for use by the compiler)
 * @param   { String }   name - name/id of the new riot tag
 * @param   { String }   html - tag template
 * @param   { String }   css - custom tag css
 * @param   { String }   attrs - root tag attributes
 * @param   { Function } fn - user function
 * @returns { String } name/id of the tag just created
 */
riot.tag2 = function(name, html, css, attrs, fn) {
  if (css) styleManager.add(css)
  //if (bpair) riot.settings.brackets = bpair
  __tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }
  return name
}

/**
 * Mount a tag using a specific tag implementation
 * @param   { String } selector - tag DOM selector
 * @param   { String } tagName - tag implementation name
 * @param   { Object } opts - tag logic
 * @returns { Array } new tags instances
 */
riot.mount = function(selector, tagName, opts) {

  var els,
    allTags,
    tags = []

  // helper functions

  function addRiotTags(arr) {
    var list = ''
    each(arr, function (e) {
      if (!/[^-\w]/.test(e)) {
        e = e.trim().toLowerCase()
        list += ',[' + RIOT_TAG_IS + '="' + e + '"],[' + RIOT_TAG + '="' + e + '"]'
      }
    })
    return list
  }

  function selectAllTags() {
    var keys = Object.keys(__tagImpl)
    return keys + addRiotTags(keys)
  }

  function pushTags(root) {
    if (root.tagName) {
      var riotTag = getAttr(root, RIOT_TAG_IS) || getAttr(root, RIOT_TAG)

      // have tagName? force riot-tag to be the same
      if (tagName && riotTag !== tagName) {
        riotTag = tagName
        setAttr(root, RIOT_TAG_IS, tagName)
        setAttr(root, RIOT_TAG, tagName) // this will be removed in riot 3.0.0
      }
      var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts)

      if (tag) tags.push(tag)
    } else if (root.length) {
      each(root, pushTags)   // assume nodeList
    }
  }

  // ----- mount code -----

  // inject styles into DOM
  styleManager.inject()

  if (isObject(tagName)) {
    opts = tagName
    tagName = 0
  }

  // crawl the DOM to find the tag
  if (typeof selector === T_STRING) {
    if (selector === '*')
      // select all the tags registered
      // and also the tags found with the riot-tag attribute set
      selector = allTags = selectAllTags()
    else
      // or just the ones named like the selector
      selector += addRiotTags(selector.split(/, */))

    // make sure to pass always a selector
    // to the querySelectorAll function
    els = selector ? $$(selector) : []
  }
  else
    // probably you have passed already a tag or a NodeList
    els = selector

  // select all the registered and mount them inside their root elements
  if (tagName === '*') {
    // get all custom tags
    tagName = allTags || selectAllTags()
    // if the root els it's just a single tag
    if (els.tagName)
      els = $$(tagName, els)
    else {
      // select all the children for all the different root elements
      var nodeList = []
      each(els, function (_el) {
        nodeList.push($$(tagName, _el))
      })
      els = nodeList
    }
    // get rid of the tagName
    tagName = 0
  }

  pushTags(els)

  return tags
}

/**
 * Update all the tags instances created
 * @returns { Array } all the tags instances
 */
riot.update = function() {
  return each(__virtualDom, function(tag) {
    tag.update()
  })
}

/**
 * Export the Virtual DOM
 */
riot.vdom = __virtualDom

/**
 * Export the Tag constructor
 */
riot.Tag = Tag
  // support CommonJS, AMD & browser
  /* istanbul ignore next */
  if (typeof exports === T_OBJECT)
    module.exports = riot
  else if (typeof define === T_FUNCTION && typeof define.amd !== T_UNDEF)
    define(function() { return riot })
  else
    window.riot = riot

})(typeof window != 'undefined' ? window : void 0);

/**
 * Global nclood library instance
 * @module nclood
 * @global
 * @namespace nclood
 */
var nclood = {};

(function () {
	var LOG_TEMPLATE = '%s %c%s %c[ nclood ]: ';
	var LogLevels = {
		DEBUG: {
			style: 'color: #bbb',
			label: 'DEBUG'
		},
		INFO: {
			style: 'color: #0b0',
			label: 'INFO '
		},
		WARN: {
			style: 'color: #ffc800',
			label: 'WARN '
		},
		ERROR: {
			style: 'color: #f00',
			label: 'ERROR'
		}
	};

	/**
	 * Error wrapper class for making logging consistent
	 * @class
	 * @param {string} msg Message to be displayed in the console.
	 */
	nclood.Error = function (msg) {
		return new Error((new Date()).toISOString() + ' ERROR [ nclood ]: ' + msg);
	};

	/**
	 * Set to true if the site is being hosted on a non-production domain or in a 'dev' directory
	 * @type {boolean}
	 */
	nclood.dev = ~window.location.host.search(/\.tst\.|\.uat\.|\.pubs\.|\.dev\.|localhost/) || ~window.location.pathname.indexOf('/dev/');

	var scripts = document.getElementsByTagName('script'), src = scripts[scripts.length - 1].src;
	
	/**
	 * HTML5 video only
	 * @type {boolean}
	 */
	nclood.html5Video = src.indexOf('html5video') > -1;
	
	/**
	 * Set to the nclood's script location
	 * @type {string}
	 */
	nclood.src = src.substr(0, src.lastIndexOf('/') + 1);

	/**
	 * Enables/Disables debugging features across the nclood library
	 * Set to match nclood.dev by default but can be changed manually if needed
	 * @type {boolean}
	 */
	nclood.debug = nclood.dev;

	if (~window.navigator.userAgent.indexOf('Nintendo WiiU')) {
		document.documentElement.classList.add('is-wiiu');
	} else if (~window.navigator.userAgent.indexOf('Nintendo 3DS')) {
		document.documentElement.classList.add('is-3ds');
	}

	/**
	 * Neatly formats all nclood.Log messages and outputs to the console
	 * @param {Object} level Log level to use
	 * @param {string} level.style Styling to use on the log level phrase
	 * @param {string} level.label Label to use in the log message
	 * @param {string} msg Message or Template to use
	 * @param {...string} subst Variable number of subsitutes to use with the message
	 * @private
	 */
	var log = function (level, msg) {
		if (!window.console || !window.console.log || !msg) return;
		if (!nclood.debug && level.label === LogLevels.DEBUG.label) return;

		window.console.log.apply(window.console, [
			LOG_TEMPLATE + msg, (new Date()).toISOString(), level.style, level.label, ''
		].concat(Array.prototype.slice.call(arguments, 2)));
	};

	/**
	 * Logging API
	 * @namespace nclood.Log
	 * @type {Object}
	 */
	nclood.Log = {
		/**
		 * Logs a DEBUG level message to the console if nclood.debug is true
		 * @param {string} msg Message to log to the console
		 * @param {...string} subst Variable number of substitutes to be interpolated in the message
		 * @function
		 * @memberof nclood.Log
		 */
		debug: log.bind(this, LogLevels.DEBUG),
		/**
		 * Logs an INFO level message to the console
		 * @param {string} msg Message to log to the console
		 * @param {...string} subst Variable number of substitutes to be interpolated in the message
		 * @function
		 * @memberof nclood.Log
		 */
		warn: log.bind(this, LogLevels.WARN),
		/**
		 * Logs a WARN level message to the console
		 * @param {string} msg Message to log to the console
		 * @param {...string} subst Variable number of substitutes to be interpolated in the message
		 * @function
		 * @memberof nclood.Log
		 */
		info: log.bind(this, LogLevels.INFO),
		/**
		 * Logs a ERROR level message to the console
		 * @param {string} msg Message to log to the console
		 * @param {...string} subst Variable number of substitutes to be interpolated in the message
		 * @function
		 * @memberof nclood.Log
		 */
		error: log.bind(this, LogLevels.ERROR)
	};

	/**
	 * Converts camel cased strings into delimited strings
	 * Useful for mapping object properties to delimited variable names
	 * @param {string} String to be converted
	 * @return {string} Delimited string
	 */
	nclood.camelToDelimited = function (str, delimiter) {
		return str.replace(/[A-Z]/g, function (match) {
			return delimiter + match;
		});
	};

	/**
	 * Cookie API
	 * @namespace nclood.Cookie
	 * @type {Object}
	 */
	nclood.Cookie = {};

	/**
	 * Sets a cookie on the document.
	 * @param {string} name Name of the cookie.
	 * @param {string} value Value of the cookie.
	 * @param {Date} expires Date object representing when the cookie should expire.
	 */
	nclood.Cookie.set = function (name, value, expires) {
		document.cookie = name + '=' + value + (expires ? '; expires=' + expires.toUTCString() : '');
	};

	/**
	 * Gets a cookie's value for the given name.
	 * @param {string} name Name of the cookie.
	 * @return {string} Value of the cookie.
	 */
	nclood.Cookie.get = function (name) {
		var match = document.cookie.match(new RegExp(name + '=([^;]+);?'));
		return match && match[1];
	};

	/**
	 * Http API
	 * @namespace nclood.Http
	 * @type {Object}
	 */
	nclood.Http = {};

	/**
	 * Makes an async http request for the given URL.
	 * @param {string} url URL of the request.
	 * @param {function} success Callback for when the request is successful.
	 * @param {function} fail Callback for when the request returns an error.
	 */
	nclood.Http.get = function (url, success, fail) {
		var req = new XMLHttpRequest();
		req.onreadystatechange = function() {
			if (req.readyState === XMLHttpRequest.DONE) {
				if (req.status === 200 && success) {
					success(req.responseText);
				} else if (req.status >= 400 && fail) {
					fail(req.responseText);
				}
			}
		};
		req.open("GET", url, true);
		req.send();
	};

	/**
	 * Creates a custom tag with the given name and options
	 * @param {string} tagName Name of the custom tag
	 * @param {Object} opts Options to be converted into attributes on the custom tag
	 * @return {Node} The custom tag node that was created
	 */
	nclood.createTag = function (tagName, opts) {
		var tag = document.createElement(tagName);
		var target = opts && opts.target, replace = opts && opts.replace;
		delete opts.target; delete opts.replace;

		for (var prop in opts) {
			var val = typeof opts[prop] === 'object' ? '{' + JSON.stringify(opts[prop]) + '}' : opts[prop];
			tag.setAttribute(nclood.camelToDelimited(prop, '-').toLowerCase(), val);
		}

		if (target) {
			target = document.querySelector(target);
			if (!replace) {
				target.innerHTML = '';
				target.appendChild(tag);
			} else {
				target.parentNode.insertBefore(tag, target);
				target.parentNode.removeChild(target);
			}
		}

		tag = riot.mount(tag, tagName)[0].root;
		tag.removeAttribute('riot-tag');
		return tag;
	};

	/**
	 * Mounts custom tags that match the selector
	 * @param {string} selector CSS3 selector for which tags to mount
	 */
	nclood.mount = function (selector) {
		var roots = [];

		riot.mount(selector).forEach(function (tag) {
			roots.push(tag.root);
		});

		return roots;
	};

	/**
	 * Test a String's falsiness
	 * Empty and 'false' strings will evaluate to false
	 * @param {string} str String to test against
	 * @return {boolean} Denotes if value is false
	 */
	nclood.isFalse = function (str) {
		return !str || (typeof str === 'string' && str.toLowerCase() === 'false');
	};

})();

/*jslint evil: true */
(function () {
	var css = 'https://alps.cdn.nintendo.net/v1/css/alps.css';

	if (!document.querySelector("link[href='" + css + "']")) {
		var accountPluginStyles = document.createElement('link');
		accountPluginStyles.rel = 'stylesheet';
		accountPluginStyles.href = css;
		document.head.appendChild(accountPluginStyles);
	}

	if (!document.querySelector("script[src='https://alps.cdn.nintendo.net/v1/js/account_en_USA.js']")) {
		if (document.readyState === 'loading') {
			document.write('<script src="https://alps.cdn.nintendo.net/v1/js/account_en_USA.js"></script>');
		} else {
			nclood.Log.error('Cannot load alps script after the body has loaded');
		}
	}
})();

/**
 * @module Nav
 * @example
 * <!-- HTML Examples -->
 * <nclood-nav highlight="amiibo" pin="true"></nclood-nav>
 * <nclood-nav language-selector="{{ '/fr/': 'Francais', '/es/': 'Espanol' }}" locale-relative-redirect="true"></nclood-nav>
 * @example
 * // Example of creating the nav element and having it replace a target element already in the DOM:
 * var nav = new nclood.Nav({
 * 	localeRelativeRedirect: true,
 * 	languageSelector: true,
 * 	target: "#nclood-nav",
 * 	replace: true
 * });
 */
(function () {

	/**
	 * Creates a Nav element that can be inserted into the DOM.
	 * @class
	 * @namespace nclood.Nav
	 * @param {Object} [opts] Options to customize the behavior of the tag
	 * @param {boolean|Object} [opts.languageSelector] Enable or customizes the language selector options and where they point to.
	 * <ul>
	 * 	<li><b>{boolean}</b> Setting to true will default to displaying English, Spanish and French.</li>
	 * 	<li><b>{Object}</b> Object representing the selector directories and labels<br>Example: <i>{ '/fr/': 'Francais', '/es/': 'Espanol' }</i></li>
	 * 	<li><b>{string}</b> Setting to "ncom" will include a 'Change Region' button that links to the country selector page</li>
	 * </ul>
	 * @param {string} [opts.highlight] Which nav option to highlight on page load. Available options include:
	 * <ul>
	 * 	<li>"wiiu"</li>
	 * 	<li>"wii</li>
	 * 	<li>"amiibo"</li>
	 * 	<li>"games"</li>
	 * 	<li>"threeds"</li>
	 * 	<li>"playn"</li>
	 * 	<li>"support"</li>
	 * </ul>
	 * @param {boolean} [opts.localeRelativeRedirect=false] Selecting from the language selector will go to the relative page for that locale when true
	 * @param {string} [opts.rootDirectory] Set this to the root directory of the site if the root is anything other than "/". This is meant to work in tandem with opts.localeRelativeRedirect.
	 * @param {boolean} [opts.pin=false] Pins the nav to the top of the page at all times
	 * @param {boolean} [opts.peek=false] Hides the nav when scrolling down and peeks back out when scrolling up
	 * @param {boolean} [opts.hideNavLinks=false] Hides the navigation links on the bottom of the nav and shrinks the nintendo logo
	 * @param {boolean} [opts.hideSearch=false] Hides the Nintendo.com search button from the navigation
	 * @param {boolean} [opts.relativeLinks=false] Makes all links in the nav relative to the current page
	 */
	nclood.Nav = function (opts) {
		return nclood.createTag('nclood-nav', opts);
	};

})();


riot.tag2('nclood-nav', '<div class="top-nav"><div class="wrapper"><a href="{nintendoURL + \'/\'}" title="Nintendo" class="logo-nintendo"><img riot-src="{images + \'logo-nintendo.svg\'}"></a><input id="search-nintendo" type="search" placeholder="Search Nintendo.com" name="term" autocorrect="off" autocapitalize="off" autocomplete="off" spellcheck="false" maxlength="128" onkeypress="{onSearchKeyPress}" onblur="{onSearchBlur}"><div if="{locale === &quot;en-us&quot; &amp;&amp; nclood.isFalse(opts.hideSearch)}" onclick="{onSearchClick}" class="top-nav-search"><span class="hide-small">Search</span><img riot-src="{images + &quot;icons/icon-close-x.svg&quot;}" class="close-x hide-small"><svg width="36" height="36" viewbox="0 0 36 36" xmlns="http://www.w3.org/2000/svg"><circle fill="#dedede" r="18" cy="18" cx="18"></circle><path d="M23.042 8.9c-3.88-3.88-10.208-3.865-14.107.034-3.9 3.899-3.915 10.227-.036 14.107 3.43 3.43 8.755 3.832 12.66 1.163l5.297 5.297a1.621 1.621 0 0 0 2.287-.005l.382-.382c.63-.631.634-1.661.006-2.289l-5.301-5.302c2.619-3.878 2.232-9.205-1.188-12.625V8.9zm-2.698 11.443c-2.424 2.423-6.358 2.433-8.77.022-2.411-2.412-2.401-6.346.023-8.77 2.423-2.423 6.357-2.433 8.769-.022 2.412 2.412 2.402 6.346-.022 8.77z"></path></svg></div><a href="/country-selector" if="{opts.languageSelector === &quot;ncom&quot;}" class="change-region">Change Region</a><select id="region-selector" onchange="{onRegionChange}" if="{regionSelector}"><option disabled="disabled" selected="selected">Change Region</option><option each="{key, value in regionSelector}" value="{this.key}">{value}</option></select><alps-account-nav></alps-account-nav></div></div><nav><input id="search-nintendo-mobile" type="search" placeholder="Search Nintendo.com" name="term" autocorrect="off" autocapitalize="off" autocomplete="off" spellcheck="false" maxlength="128" if="{locale === &quot;en-us&quot;}" onkeypress="{onSearchKeyPress}" onblur="{onSearchBlur}"><div if="{nclood.isFalse(opts.hideNavLinks)}" class="wrapper"><a href="{nintendoURL + \'/wiiu/\'}" data-section="wiiu" onclick="{onNavClick}" onmouseenter="{onNavMouseEnter}" onmouseout="{onNavMouseOut}" class="{active: activeSection === &quot;wiiu&quot;}">Wii U</a><a href="{nintendoURL + \'/3ds/\'}" data-section="threeds" onclick="{onNavClick}" onmouseenter="{onNavMouseEnter}" onmouseout="{onNavMouseOut}" class="{active: activeSection === &quot;threeds&quot;}">Nintendo 3DS</a><a href="{nintendoURL + \'/games/\'}" data-section="gamestore" onclick="{onNavClick}" if="{locale !== \'es-la\'}" onmouseenter="{onNavMouseEnter}" onmouseout="{onNavMouseOut}" class="{active: activeSection === &quot;gamestore&quot;}">Game Store</a><a href="{nintendoURL + \'/amiibo/\'}" data-section="amiibo" onclick="{onNavClick}" onmouseenter="{onNavMouseEnter}" onmouseout="{onNavMouseOut}" class="hide-small {active: activeSection === &quot;amiibo&quot;}">amiibo</a><a href="http://play.nintendo.com/" data-section="playnintendo" onclick="{onNavClick}" if="{locale.indexOf(\'en\') === 0}" onmouseenter="{onNavMouseEnter}" onmouseout="{onNavMouseOut}" class="hide-small {active: activeSection === &quot;playnintendo&quot;}">Play Nintendo</a><a href="http://support.nintendo.com/nin-nav-en/home" data-section="support" onclick="{onNavClick}" onmouseenter="{onNavMouseEnter}" onmouseout="{onNavMouseOut}" class="hide-small {active: activeSection === &quot;support&quot;}">Support</a><a href="https://my.nintendo.com/" data-section="mynintendo" onclick="{onNavClick}" onmouseenter="{onNavMouseEnter}" onmouseout="{onNavMouseOut}" class="hide-small {active: activeSection === &quot;mynintendo&quot;}">My Nintendo</a><a data-section="additional" onclick="{onNavClick}" onmouseenter="{onNavMouseEnter}" onmouseout="{onNavMouseOut}" class="hide-large {active: activeSection === &quot;additional&quot;}"><svg viewbox="0 0 40 8" fill="#888"><circle cx="4" cy="4" r="4"></circle><circle cx="20" cy="4" r="4"></circle><circle cx="36" cy="4" r="4"></circle></svg></a></div></nav><div if="{nclood.isFalse(opts.hideNavLinks)}" class="expanded-nav-container {show: activeSection}"><div class="backdrop"></div><div class="expanded-nav-wiiu {active: activeSection === &quot;wiiu&quot;}"><div class="wrapper"><img riot-src="{images + &quot;line-art/mario-running.svg&quot;}" class="line-art line-art-sway mario-running"><img riot-src="{images + &quot;line-art/mushroom.svg&quot;}" class="line-art mushroom"><img riot-src="{images + &quot;line-art/goomba-close-mouth.svg&quot;}" class="line-art line-art-rock goomba"><img riot-src="{images + &quot;line-art/question-block.svg&quot;}" class="line-art question-block"><div class="main-tiles"><a href="{nintendoURL + \'/wiiu/\'}" data-metric-link="wiiu:wiiu" class="wiiu-home"><img riot-src="{images + &quot;icons/icon-wii-u.svg&quot;}" class="hide-large"><div class="bg-layer"></div><div class="link-title">Wii&nbsp;U</div><div class="link-copy">Have a blast playing Nintendo\'s biggest games at home.</div></a><a if="{locale !== &quot;es-la&quot;}" href="{nintendoURL + \'/wiiu/buynow\'}" data-metric-link="wiiu:buy now" class="wiiu-buynow hide-small"><div class="link-title">Buy now</div></a><a if="{locale === &quot;es-la&quot;}" href="{nintendoURL + \'/retailers\'}" data-metric-link="wiiu:buy now" class="wiiu-buynow hide-small"><div class="link-title">Buy now</div></a></div><div class="small-tiles"><a if="{~locale.indexOf(\'en\')}" href="{nintendoURL + \'/wiiu/what-is-wiiu\'}" data-metric-link="wiiu:what is wii u" class="wiiu-whatis"><div class="bg-layer"></div><div class="link-title">What is Wii&nbsp;U?</div></a><a href="{nintendoURL + \'/wiiu/features\'}" data-metric-link="wiiu:features" class="wiiu-features"><div class="bg-layer"></div><div class="link-title">Features</div></a><a if="{~locale.indexOf(\'en\')}" href="{nintendoURL + \'/games/wiiu/\'}" data-metric-link="wiiu:games" class="wiiu-games"><div class="bg-layer"></div><div class="link-title">Wii&nbsp;U games</div></a><a href="{nintendoURL + \'/wiiu/built-in-software/\'}" data-metric-link="wiiu:built in software" class="wiiu-software"><div class="bg-layer"></div><div class="link-title">Built-in software</div></a><a if="{locale === \'en-us\'}\' }" href="{nintendoURL + \'/wiiu/accessories\'}" data-metric-link="wiiu:accessories" class="wiiu-accessories"><div class="bg-layer"></div><div class="link-title">Accessories</div></a><a href="{nintendoURL + \'/wiiu/faq\'}" data-metric-link="wiiu:faq" class="wiiu-faq"><div class="bg-layer"></div><div class="link-title">FAQ</div></a><a if="{locale !== &quot;es-la&quot;}" href="{nintendoURL + \'/wiiu/buynow\'}" data-metric-link="wiiu:buy now" class="wiiu-buynow hide-large"><div class="bg-layer"></div><div class="link-title">Buy now</div></a><a if="{locale === &quot;es-la&quot;}" href="{nintendoURL + \'/retailers\'}" data-metric-link="wiiu:buy now" class="wiiu-buynow hide-large"><div class="bg-layer"></div><div class="link-title">Buy now</div></a></div></div></div><div class="expanded-nav-threeds {active: activeSection === &quot;threeds&quot;}"><div class="wrapper"><img riot-src="{images + &quot;line-art/peach.svg&quot;}" class="line-art line-art-sway peach"><img riot-src="{images + &quot;line-art/pipe.svg&quot;}" class="line-art pipe"><img riot-src="{images + &quot;line-art/luigi.svg&quot;}" class="line-art line-art-hover luigi"><div class="main-tiles"><a href="{nintendoURL + \'/3ds/\'}" data-metric-link="threeds:3ds" class="threeds-home"><img riot-src="{images + &quot;icons/icon-threeds.svg&quot;}" class="hide-large"><div class="bg-layer"></div><div class="link-title">Nintendo&nbsp;3DS family</div><div class="link-copy">Play anytime, anyplace with our portable systems.</div></a><a if="{locale !== &quot;es-la&quot;}" href="{nintendoURL + \'/3ds/buynow\'}" data-metric-link="threeds:buy now" class="threeds-buynow hide-small"><div class="link-title">Buy now</div></a><a if="{locale === &quot;es-la&quot;}" href="{nintendoURL + \'/retailers\'}" data-metric-link="threeds:buy now" class="threeds-buynow hide-small"><div class="link-title">Buy now</div></a></div><div class="small-tiles"><a href="{nintendoURL + \'/3ds/what-is-nintendo-3ds\'}" data-metric-link="threeds:what is nintendo 3ds" if="{locale === &quot;en-us&quot;}" class="threeds-whatis"><div class="bg-layer"></div><div class="link-title">What is Nintendo&nbsp;3DS?</div></a><a href="{nintendoURL + \'/2ds/what-is-nintendo-2ds\'}" data-metric-link="threeds:what is nintendo 2ds" class="threeds-whatis2ds"><div class="bg-layer"></div><div class="link-title">What is Nintendo&nbsp;2DS?</div></a><a href="{nintendoURL + \'/games/3ds/\'}" data-metric-link="threeds:games" if="{locale === &quot;en-us&quot;}" class="threeds-games"><div class="bg-layer"></div><div class="link-title">Nintendo&nbsp;3DS games</div></a><a href="{nintendoURL + \'/3ds/features\'}" data-metric-link="threeds:features" class="threeds-features"><div class="bg-layer"></div><div class="link-title">Features</div></a><a href="{nintendoURL + \'/3ds/built-in-software/\'}" data-metric-link="threeds:built in software" class="threeds-software"><div class="bg-layer"></div><div class="link-title">Built-in software</div></a><a href="{nintendoURL + \'/3ds/faq\'}" data-metric-link="threeds:faq" class="threeds-faq"><div class="bg-layer"></div><div class="link-title">FAQ</div></a><a if="{locale !== &quot;es-la&quot;}" href="{nintendoURL + \'/3ds/buynow\'}" data-metric-link="threeds:buy now" class="threeds-buynow hide-large"><div class="bg-layer"></div><div class="link-title">Buy now</div></a><a if="{locale === &quot;es-la&quot;}" href="{nintendoURL + \'/retailers\'}" data-metric-link="threeds:buy now" class="threeds-buynow hide-large"><div class="bg-layer"></div><div class="link-title">Buy now</div></a></div></div></div><div if="{locale !== &quot;es-la&quot;}" class="expanded-nav-gamestore {active: activeSection === &quot;gamestore&quot;}"><div class="wrapper"><img riot-src="{images + &quot;line-art/brick.svg&quot;}" class="line-art brick"><img riot-src="{images + &quot;line-art/bobomb.svg&quot;}" class="line-art line-art-sway bobomb"><img riot-src="{images + &quot;line-art/bowser.svg&quot;}" class="line-art line-art-grow bowser"><div class="main-tiles"><a href="{nintendoURL + \'/games/\'}" data-metric-link="games:game store" class="games-games"><img riot-src="{images + &quot;icons/icon-game-store.svg&quot;}" class="hide-large"><div class="bg-layer"></div><div class="link-title">Game Store</div><div class="link-copy">Browse, buy, and download games.</div></a></div><div class="small-tiles"><a href="{nintendoURL + \'/games/wiiu/\'}" data-metric-link="games:wii u games" if="{locale.indexOf(&quot;en&quot;) === 0}" class="games-wiiu"><div class="bg-layer"></div><div class="link-title">Wii&nbsp;U games</div></a><a href="{nintendoURL + \'/games/3ds/\'}" data-metric-link="games:3ds games" if="{locale.indexOf(&quot;en&quot;) === 0}" class="games-threeds"><div class="bg-layer"></div><div class="link-title">Nintendo&nbsp;3DS games</div></a><a href="{nintendoURL + \'/games/game-guide\'}" data-metric-link="games:all games" if="{locale.indexOf(&quot;en&quot;) === 0}" class="games-all"><div class="bg-layer"></div><div class="link-title">All games</div></a><a href="https://miitomo.com/en/" data-metric-link="games:miitomo" class="games-miitomo"><div class="bg-layer"></div><div class="link-title">Miitomo&trade;</div></a><a href="{nintendoURL + \'/games/sales-and-deals\'}" data-metric-link="games:sales and deals" if="{locale.indexOf(&quot;en&quot;) === 0}" class="games-sales-and-offers"><div class="bg-layer"></div><div class="link-title">Sales and deals</div></a><a href="{nintendoURL + \'/games/coming-soon\'}" data-metric-link="games:coming soon" if="{locale.indexOf(&quot;en&quot;) === 0}" class="games-coming-soon"><div class="bg-layer"></div><div class="link-title">Coming soon</div></a></div></div></div><div class="expanded-nav-amiibo {active: activeSection === &quot;amiibo&quot;}"><div class="wrapper"><div class="main-tiles"><a href="{nintendoURL + \'/amiibo/\'}" data-metric-link="amiibo:amiibo" class="amiibo-home"><div class="bg-layer"></div><div class="link-title">amiibo</div><div class="link-copy">Supercharge your gameplay.</div></a><a if="{locale !== &quot;es-la&quot;}" href="{nintendoURL + \'/amiibo/buynow\'}" data-metric-link="amiibo:buy now" class="amiibo-buynow hide-small"><div class="link-title">Buy now</div></a><a if="{locale === &quot;es-la&quot;}" href="{nintendoURL + \'/retailers\'}" data-metric-link="amiibo:buy now" class="amiibo-buynow hide-small"><div class="link-title">Buy now</div></a></div><div class="small-tiles"><a href="{nintendoURL + \'/amiibo/what-is-amiibo\'}" data-metric-link="amiibo:what is amiibo" class="amiibo-whatis"><div class="bg-layer"></div><div class="link-title">What is amiibo?</div></a><a href="{nintendoURL + \'/amiibo/line-up\'}" data-metric-link="amiibo:lineup" class="amiibo-lineup"><div class="bg-layer"></div><div class="link-title">Lineup</div></a><a href="{nintendoURL + \'/amiibo/games/\'}" data-metric-link="amiibo:games" class="amiibo-games"><div class="bg-layer"></div><div class="link-title">Games</div></a><a href="{nintendoURL + \'/amiibo/compatibility\'}" data-metric-link="amiibo:compatibility" class="amiibo-compatibility"><div class="bg-layer"></div><div class="link-title">Compatibility</div></a><a href="{nintendoURL + \'/amiibo/faq\'}" data-metric-link="amiibo:faq" class="amiibo-faq"><div class="bg-layer"></div><div class="link-title">FAQ</div></a><a if="{locale !== &quot;es-la&quot;}" href="{nintendoURL + \'/amiibo/buynow\'}" data-metric-link="amiibo:buy now" class="amiibo-buynow hide-large"><div class="bg-layer"></div><div class="link-title">Buy now</div></a><a if="{locale === &quot;es-la&quot;}" href="{nintendoURL + \'/retailers\'}" data-metric-link="amiibo:buy now" class="amiibo-buynow hide-large"><div class="bg-layer"></div><div class="link-title">Buy now</div></a></div></div></div><div if="{locale.indexOf(&quot;en&quot;) === 0}" class="expanded-nav-playnintendo {active: activeSection === &quot;playnintendo&quot;}"><div class="wrapper"><img riot-src="{images + &quot;line-art/lakitu.svg&quot;}" class="line-art line-art-hover lakitu"><img riot-src="{images + &quot;line-art/spiny.svg&quot;}" class="line-art line-art-sway spiny"><img riot-src="{images + &quot;line-art/mario-and-yoshi.svg&quot;}" class="line-art line-art-sway mario-and-yoshi"><img riot-src="{images + &quot;line-art/goomba.svg&quot;}" class="line-art line-art-sway goomba"><img riot-src="{images + &quot;line-art/bobomb.svg&quot;}" class="line-art line-art-sway bobomb"><div class="main-tiles"><a href="http://play.nintendo.com/" data-metric-link="playnintendo:play nintendo" class="playnintendo-home"><div class="bg-layer"></div><div class="link-title">Play Nintendo</div><div class="link-copy">Fun stuff for kids!</div></a></div><div class="small-tiles"><a href="http://play.nintendo.com/themes/friends/" data-metric-link="playnintendo:friends" class="playnintendo-friends"><div class="bg-layer"></div><div class="link-title">Friends</div></a><a href="http://play.nintendo.com/activities/" data-metric-link="playnintendo:explore" class="playnintendo-explore"><div class="bg-layer"></div><div class="link-title">Explore</div></a><a href="http://play.nintendo.com/news-tips/" data-metric-link="playnintendo:news and tips" class="playnintendo-news"><div class="bg-layer"></div><div class="link-title">News &amp; tips</div></a><a href="http://play.nintendo.com/parents/" data-metric-link="playnintendo:parents" class="playnintendo-parents"><div class="bg-layer"></div><div class="link-title">For parents</div></a></div></div></div><div class="expanded-nav-support {active: activeSection === &quot;support&quot;}"><div class="wrapper"><img riot-src="{images + &quot;line-art/question-block.svg&quot;}" class="line-art question-block"><img riot-src="{images + &quot;line-art/goomba-open-mouth.svg&quot;}" class="line-art line-art-rock goomba-1"><img riot-src="{images + &quot;line-art/goomba-close-mouth.svg&quot;}" class="line-art line-art-rock goomba-2"><img riot-src="{images + &quot;line-art/toads-left.svg&quot;}" class="line-art toads-left"><img riot-src="{images + &quot;line-art/toads-middle.svg&quot;}" class="line-art toads-middle"><img riot-src="{images + &quot;line-art/toads-right.svg&quot;}" class="line-art toads-right"><div class="main-tiles"><a href="http://support.nintendo.com/nin-nav-en/home" data-metric-link="support:support" class="support-support"><div class="bg-layer"></div><div class="link-title">Support</div><div class="link-copy">Get answers to your questions or contact us for help.</div></a></div><div class="small-tiles"><a href="http://support.nintendo.com/nin-nav-en/hubs-wiiu" data-metric-link="support:wii u" class="support-wiiu"><img riot-src="{images + &quot;line-art/wii-u-support.svg&quot;}"><div class="link-title">Wii&nbsp;U</div></a><a href="http://support.nintendo.com/nin-nav-en/hubs-3ds" data-metric-link="support:3ds" class="support-threeds"><img riot-src="{images + &quot;line-art/threeds-support.svg&quot;}"><div class="link-title">Nintendo&nbsp;3DS</div></a><a href="http://support.nintendo.com/nin-nav-en/hubs-forums" data-metric-link="support:support forums" class="support-forums"><img riot-src="{images + &quot;line-art/support-forums.svg&quot;}"><div class="link-title">Support forums</div></a><a href="http://support.nintendo.com/nin-nav-en/hubs-internet-connections" data-metric-link="support:internet connections" class="support-internet"><img riot-src="{images + &quot;line-art/internet-connections.svg&quot;}"><div class="link-title">Internet connections</div></a><a href="http://support.nintendo.com/nin-nav-en/hubs-digital-purchases" data-metric-link="support:digital purchases" class="support-digital"><img riot-src="{images + &quot;line-art/digital-purchases.svg&quot;}"><div class="link-title">Digital purchases</div></a><a href="http://support.nintendo.com/nin-nav-en/hubs-repair" data-metric-link="support:set up repair" class="support-repair"><img riot-src="{images + &quot;line-art/set-up-repair.svg&quot;}"><div class="link-title">Set up repair</div></a></div></div></div><div class="expanded-nav-mynintendo {active: activeSection === &quot;mynintendo&quot;}"><div class="wrapper"><div class="main-tiles"><a href="https://my.nintendo.com/" data-metric-link="mynintendo:my nintendo" class="mynintendo-home"><div class="bg-layer"></div><div class="link-title">My Nintendo</div><div class="link-copy">Join our free rewards program today.</div></a></div><div class="small-tiles"><a href="https://my.nintendo.com/getting_started" data-metric-link="mynintendo:what is my nintendo" class="mynintendo-whatis"><img riot-src="{images + \'logo-my-nintendo.svg\'}"><div class="link-title">What is My&nbsp;Nintendo?</div></a><a href="https://my.nintendo.com/rewards" data-metric-link="mynintendo:rewards" class="mynintendo-rewards"><img riot-src="{images + \'line-art/rewards.svg\'}"><div class="link-title">Rewards</div></a><a href="https://my.nintendo.com/missions" data-metric-link="mynintendo:missions" class="mynintendo-missions"><img riot-src="{images + \'line-art/missions.svg\'}"><div class="link-title">Missions</div></a><a href="https://my.nintendo.com/about_point" data-metric-link="mynintendo:about points" class="mynintendo-points"><div class="bg-layer"></div><div class="link-title">About points</div></a></div></div></div><div class="expanded-nav-additional {active: activeSection === &quot;additional&quot;}"><div class="wrapper"><div class="small-tiles"><a href="{nintendoURL + \'/amiibo/\'}" data-metric-link="additional:amiibo" class="additional-amiibo"><img riot-src="{images + &quot;line-art/amiibo.svg&quot;}"><div class="link-title">amiibo</div></a><a href="http://play.nintendo.com/" data-metric-link="additional:play nintendo" if="{locale.indexOf(&quot;en&quot;) === 0}" class="additional-play-nintendo"><img riot-src="{images + &quot;line-art/play-nintendo.svg&quot;}"><div class="link-title">Play Nintendo</div></a><a href="http://support.nintendo.com/nin-nav-en/home" data-metric-link="additional:support" class="additional-support"><img riot-src="{images + &quot;line-art/support.svg&quot;}"><div class="link-title">Support</div></a><a href="https://my.nintendo.com/" data-metric-link="additional:my nintendo" class="additional-my-nintendo"><img riot-src="{images + &quot;logo-my-nintendo.svg&quot;}"></a></div></div></div></div>', '', 'id="nclood-nav" lang="en-us" onmouseout="{onExpandedNavMouseOut}" class="{expanded: activeSection, pin: pin, gamestore: activeSection === \'gamestore\', additional: activeSection === \'additional\', search-active: searchActive, no-nav-links: !nclood.isFalse(opts.hideNavLinks)}"', function(opts) {
    this.images = nclood.src + '../modules/nav/images/';
    this.pin = 'pin' in opts && opts.pin !== 'false';
    this.locale = 'en-us';
    var localePrefix = '/' + this.locale.substring(0, 2) + '_' + this.locale.substring(3, 5).toUpperCase();
    if (this.locale === 'en-us') localePrefix = '';
    if ('relativeLinks' in opts && opts.relativeLinks !== 'false') this.nintendoURL = localePrefix;
    else this.nintendoURL = 'http://www.nintendo.com' + localePrefix;

    if (!nclood.isFalse(opts.languageSelector)) {
    	if (typeof opts.languageSelector === 'object') {
    		this.regionSelector = opts.languageSelector;
    	} else if (opts.languageSelector !== 'ncom') {
    		if (opts.rootDirectory && opts.rootDirectory[0] !== "/") {
    			opts.rootDirectory =  "/" + opts.rootDirectory;
    		}
    		var urlRoot = opts.rootDirectory || "";
    		var usingURLPath = opts.localeRelativeRedirect ? window.location.pathname.replace(urlRoot, "").replace("//", "") : "";
    		if (usingURLPath[0] === "/") {
    			usingURLPath = usingURLPath.substring(1, usingURLPath.length);
    		}

    		this.regionSelector = {};
    		if (this.locale.indexOf('en') !== 0) this.regionSelector[urlRoot + "/" + usingURLPath] = 'United States (English)';
    		if (this.locale !== 'fr-ca') this.regionSelector[urlRoot + "/fr/" + usingURLPath] = 'Canada (Français)';
    		if (this.locale !== 'es-la') this.regionSelector[urlRoot + "/es/" + usingURLPath] = 'Latin America (Español)';
    	}
    }

    var isAChildOf = function (parent, possibleChild) {
    	if (!possibleChild || !possibleChild.parentNode) return false;
    	if (possibleChild.parentNode === parent) return true;
    	return isAChildOf(parent, possibleChild.parentNode);
    };

    var hoverTimeout, expandedNav, nav;

    this.onSearchClick = function (event) {
    	if (this.blurred) {
    		this.blurred = false;
    		return true;
    	}
    	this.searchActive = true;
    	var searchInput = (window.innerWidth <= 768) ?
    		this.root.querySelector('#search-nintendo-mobile') :
    		this.root.querySelector('#search-nintendo');
    	searchInput.value = '';
    	searchInput.focus();
    };

    this.onNavMouseEnter = function (event) {
    	if ('ontouchstart' in document.documentElement || window.innerWidth <= 768) return true;
    	if (event.target.dataset.section === this.activeSection) return true;
    	hoverTimeout = setTimeout(function () {
    		this.activeSection = event.target.dataset.section;
    		this.update();
    		this.resizeBackdrop();
    	}.bind(this), this.activeSection ? 200 : 600);
    };

    this.onNavMouseOut = function (event) {
    	clearTimeout(hoverTimeout);
    };

    this.onSearchKeyPress = function (event) {

    	if (event.keyCode !== 13) return true;
    	window.location = 'http://www.nintendo.com/search/#/results/' + encodeURIComponent(event.target.value) + '/1';
    };

    this.onNavClick = function (event) {
    	if ('ontouchstart' in document.documentElement || window.innerWidth <= 768) {
    		if (event.currentTarget.dataset.section === this.activeSection) {
    			this.activeSection = null;
    		} else {
    			this.activeSection = event.currentTarget.dataset.section;
    		}
    		this.update();
    		this.resizeBackdrop();
    		event.preventDefault();
    	}
    };

    this.onRegionChange = function (event) {
    	window.location = event.currentTarget.value;
    };

    this.resizeBackdrop = function () {
    	var backdrop = this.root.querySelector('.expanded-nav-container .backdrop');
    	if (!this.activeSection) {
    		backdrop.style.height = '0px';
    	} else {
    		var activeSection = this.root.querySelector('.expanded-nav-container > div.active');
    		backdrop.style.height = activeSection.offsetHeight + 'px';
    	}
    };

    this.onExpandedNavMouseOut = function (event) {
    	if (!this.activeSection) return true;
    	var fromElem = event.target;
    	var toElem = event.relatedTarget;
    	if (!toElem) return true;
    	if (!(isAChildOf(expandedNav, fromElem) && isAChildOf(expandedNav, toElem)) &&
    	    !(isAChildOf(expandedNav, fromElem) && isAChildOf(nav, toElem)) &&
    		 !(isAChildOf(nav, fromElem) && isAChildOf(expandedNav, toElem)) &&
    		 !(isAChildOf(nav, fromElem) && isAChildOf(nav, toElem))) {
    		this.activeSection = null;
    		this.update();
    		this.resizeBackdrop();
    	}
    };

    this.onSearchBlur = function (event) {
    	this.searchActive = false;
    	this.blurred = true;
    };

    if (this.pin) {
    	var spacer = document.createElement('div');
    	spacer.classList.add('nclood-nav-spacer');
    	if (!nclood.isFalse(opts.hideNavLinks)) {
    		spacer.classList.add('no-nav-links');
    	}
    	if (document.body) {
    		document.body.insertBefore(spacer, document.body.childNodes[0]);
    	} else {
    		document.addEventListener('DOMContentLoaded', function () {
    			document.body.insertBefore(spacer, document.body.childNodes[0]);
    		});
    	}

    	var prevScrollY = window.scrollY;
    	var checkScrollPosition = function () {
    		setTimeout(function () {
    			if (spacer.getBoundingClientRect().bottom < 0) {
    				document.body.classList.add('not-at-top');
    			} else {
    				document.body.classList.remove('not-at-top');
    			}
    			if (window.scrollY < prevScrollY) {
    				document.body.classList.add('scrolling-up');
    			} else if (window.scrollY > prevScrollY) {
    				document.body.classList.remove('scrolling-up');
    			}
    			prevScrollY = window.scrollY
    			window.requestAnimationFrame(checkScrollPosition);
    		}, 100);
    	};

    	if ('peek' in opts) {
    		checkScrollPosition();
    	}
    }

    this.on('mount', function () {
    	expandedNav = this.root.querySelector('.expanded-nav-container');
    	nav = this.root.querySelector('nav');
    });
});
riot.mount('*');
